(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["chunks/ssr/_077f99._.js", {

"[project]/src/app/page.tsx (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/src/app/page.tsx (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/node_modules_next_dcda51._.js",
    "included": [
      "[project]/node_modules/next/image.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/buffer/index.js (ecmascript)",
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_react_jsx-dev-runtime_9d73fc.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@socket_io_component-emitter_index_mjs_f72b43._.js",
    "included": [
      "[project]/node_modules/@socket.io/component-emitter/index.mjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_176a9f._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_c2b48a._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_723705.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_2a645c.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_engine_io-parser_build_esm_index_1091cf.js",
    "included": [
      "[project]/node_modules/engine.io-parser/build/esm/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_engine_io-client_build_esm_index_d3baad.js",
    "included": [
      "[project]/node_modules/engine.io-client/build/esm/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_socket_io-parser_build_esm_index_5ee601.js",
    "included": [
      "[project]/node_modules/socket.io-parser/build/esm/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_socket_io-client_build_esm_index_9909f2.js",
    "included": [
      "[project]/node_modules/socket.io-client/build/esm/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/src_app_page_tsx_b53fce._.js",
    "included": [
      "[project]/src/app/page.tsx (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/src_app_page_module_b5a149.css",
    "included": [
      "[project]/src/app/page.module.css (css, css module)"
    ],
    "moduleChunks": [
      "_next/static/chunks/src_app_page_module_fb38f0.css"
    ]
  },
  "_next/static/chunks/src_app_page_tsx_5771e1._.js"
];

})()),
"[project]/src/app/page.tsx (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$src$2f$app$2f$page$2e$tsx__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$src$2f$app$2f$page$2e$tsx__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/src/app/page.tsx (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/src/app/page.tsx (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$src$2f$app$2f$page$2e$tsx__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$src$2f$app$2f$page$2e$tsx__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/src/app/page.tsx (ecmascript, client chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => __turbopack_import__("[project]/src/app/page.tsx (ecmascript, rsc)"),
    chunks: () => chunks,
});
const chunks = [
  "chunks/ssr/src_app_page_module_b5a149.css"
];

})()),
"[project]/src/app/layout.tsx (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

__turbopack_esm__({
    "default": ()=>RootLayout,
    "metadata": ()=>metadata
});
var __TURBOPACK__imported__module__$5b$next$5d2f$internal$2f$font$2f$google$2f$inter_59dee874$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[next]/internal/font/google/inter_59dee874.js (ecmascript, rsc)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$dev$2d$runtime$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
const metadata = {
    title: 'Create Next App',
    description: 'Generated by create next app'
};
function RootLayout({ children }) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$dev$2d$runtime$2e$js__$28$ecmascript$29$__["jsxDEV"]("html", {
        lang: "en",
        children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$dev$2d$runtime$2e$js__$28$ecmascript$29$__["jsxDEV"]("body", {
            className: __TURBOPACK__imported__module__$5b$next$5d2f$internal$2f$font$2f$google$2f$inter_59dee874$2e$js__$28$ecmascript$29$__["default"].className,
            children: children
        }, void 0, false, {
            fileName: "<[project]/src/app/layout.tsx>",
            lineNumber: 18,
            columnNumber: 7
        }, this)
    }, void 0, false, {
        fileName: "<[project]/src/app/layout.tsx>",
        lineNumber: 17,
        columnNumber: 5
    }, this);
}

})()),
"[project]/src/app/layout.tsx (ecmascript, client chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => __turbopack_import__("[project]/src/app/layout.tsx (ecmascript, rsc)"),
    chunks: () => chunks,
});
const chunks = [
  "chunks/rsc/[next]_internal_font_google_inter_59dee874_module_b5a149.css",
  "chunks/rsc/src_app_globals.css"
];

})()),
"[project]/src/app/favicon.ico (static, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_export_value__("/_next/static/media/favicon.45db1c09.ico");
})()),
"[project]/src/app/favicon.ico.mjs/(IMAGE)/[project]/src/app/favicon.ico (static) (structured image object, ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

__turbopack_esm__({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$favicon$2e$ico__$28$static$29$__ = __turbopack_import__("[project]/src/app/favicon.ico (static, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
const __TURBOPACK__default__export__ = {
    src: __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$favicon$2e$ico__$28$static$29$__["default"],
    width: 256,
    height: 256
};

})()),
"[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_8bfabc._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_0bb5ef._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_5503db.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_d70a1d.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_process_browser_d734a8.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_react_index_0fe052.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_build_polyfills_process_930efa.js",
    "included": [
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_app-router-context_898dd5.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_hooks-client-context_ed2655.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/hooks-client-context.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_server-inserted-html_783da8.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_lazy-dynamic_dynamic-no-ssr_5b5544.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_client_components_error-boundary_b53fce.js",
    "included": [
      "[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_error-boundary_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, client chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => __turbopack_import__("[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, rsc)"),
    chunks: () => chunks,
});
const chunks = [];

})()),
"[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/app-router.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/[next]_overlay_client_ts_5ecd66._.js",
    "included": [
      "[next]/overlay/client.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_dev_hot-reloader_tsx_db9090._.js",
    "included": [
      "[next]/dev/hot-reloader.tsx (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_platform_index_cf3e50.js",
    "included": [
      "[next]/compiled/platform/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_css_escape_index_7c772f.js",
    "included": [
      "[next]/compiled/css.escape/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_strip-ansi_index_0a9489.js",
    "included": [
      "[next]/compiled/strip-ansi/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_stacktrace-parser_index_b13037.js",
    "included": [
      "[next]/compiled/stacktrace-parser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_anser_index_aab8ed.js",
    "included": [
      "[next]/compiled/anser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[turbopack]_dev_client_a4c55d._.js",
    "included": [
      "[turbopack]/dev/client/hmr-client.ts (ecmascript)",
      "[turbopack]/dev/client/websocket.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_b402f2._.js",
    "included": [
      "[project]/node_modules/next/dist/client/app-call-server.js (ecmascript)",
      "[project]/node_modules/next/dist/client/add-base-path.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/navigation.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/not-found.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/not-found-boundary.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/app-router.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hooks-client-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/scheduler/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-dom/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.js (ecmascript)",
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)",
      "[project]/node_modules/next/dist/server/app-render/get-segment-param.js (ecmascript)",
      "[project]/node_modules/next/dist/server/future/helpers/interception-routes.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_a172d2._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_910d6d._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_8e89a0.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_6bb19e.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_app-router_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/[next]_overlay_client_ts_8e0a93._.js",
    "included": [
      "[next]/overlay/client.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_dev_hot-reloader_tsx_0655d7._.js",
    "included": [
      "[next]/dev/hot-reloader.tsx (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_platform_index_92dc0d.js",
    "included": [
      "[next]/compiled/platform/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_css_escape_index_368474.js",
    "included": [
      "[next]/compiled/css.escape/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_strip-ansi_index_ef6bc7.js",
    "included": [
      "[next]/compiled/strip-ansi/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_stacktrace-parser_index_0c555c.js",
    "included": [
      "[next]/compiled/stacktrace-parser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_anser_index_4da8bb.js",
    "included": [
      "[next]/compiled/anser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[turbopack]_dev_client_dfbd04._.js",
    "included": [
      "[turbopack]/dev/client/hmr-client.ts (ecmascript)",
      "[turbopack]/dev/client/websocket.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_378e8b._.js",
    "included": [
      "[project]/node_modules/next/dist/client/add-base-path.js (ecmascript)",
      "[project]/node_modules/next/dist/client/app-call-server.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/navigation.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/not-found.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/not-found-boundary.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/scheduler/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-dom/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.js (ecmascript)",
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hooks-client-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js (ecmascript)",
      "[project]/node_modules/next/dist/server/app-render/get-segment-param.js (ecmascript)",
      "[project]/node_modules/next/dist/server/future/helpers/interception-routes.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_802010._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_d98411._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_087633.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_36b36c.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_layout-router_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_7dd036._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_5180f8._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_7f91d5.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_7bf983.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_process_browser_59bcba.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_react_index_8b15c6.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_build_polyfills_process_785375.js",
    "included": [
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_app-router-context_6dabfc.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_client_components_render-from-template-context_b53fce.js",
    "included": [
      "[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_render-from-template-context_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createAsyncLocalStorage", {
    enumerable: true,
    get: function() {
        return createAsyncLocalStorage;
    }
});
const sharedAsyncLocalStorageNotAvailableError = new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
class FakeAsyncLocalStorage {
    disable() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    getStore() {
        return undefined;
    }
    run() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    exit() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    enterWith() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
}
function createAsyncLocalStorage() {
    if (globalThis.AsyncLocalStorage) {
        return new globalThis.AsyncLocalStorage();
    }
    return new FakeAsyncLocalStorage();
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/static-generation-async-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "staticGenerationAsyncStorage", {
    enumerable: true,
    get: function() {
        return staticGenerationAsyncStorage;
    }
});
const _asynclocalstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)");
const staticGenerationAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DYNAMIC_ERROR_CODE: null,
    DynamicServerError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DYNAMIC_ERROR_CODE: function() {
        return DYNAMIC_ERROR_CODE;
    },
    DynamicServerError: function() {
        return DynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
class DynamicServerError extends Error {
    constructor(type){
        super("Dynamic server usage: " + type);
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/static-generation-bailout.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "staticGenerationBailout", {
    enumerable: true,
    get: function() {
        return staticGenerationBailout;
    }
});
const _hooksservercontext = __turbopack_require__("[project]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, rsc)");
const _staticgenerationasyncstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-async-storage.js (ecmascript, rsc)");
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args);
        this.code = "NEXT_STATIC_GEN_BAILOUT";
    }
}
const staticGenerationBailout = (reason, opts)=>{
    const staticGenerationStore = _staticgenerationasyncstorage.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {
        return true;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.dynamicShouldError) {
        const { dynamic = "error", link } = opts || {};
        const suffix = link ? " See more info here: " + link : "";
        throw new StaticGenBailoutError('Page with `dynamic = "' + dynamic + "\"` couldn't be rendered statically because it used `" + reason + "`." + suffix);
    }
    if (staticGenerationStore) {
        staticGenerationStore.revalidate = 0;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {
        const err = new _hooksservercontext.DynamicServerError(reason);
        staticGenerationStore.dynamicUsageDescription = reason;
        staticGenerationStore.dynamicUsageStack = err.stack;
        throw err;
    }
    return false;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/searchparams-bailout-proxy.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createSearchParamsBailoutProxy", {
    enumerable: true,
    get: function() {
        return createSearchParamsBailoutProxy;
    }
});
const _staticgenerationbailout = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-bailout.js (ecmascript, rsc)");
function createSearchParamsBailoutProxy() {
    return new Proxy({}, {
        get (_target, prop) {
            if (typeof prop === "string") {
                (0, _staticgenerationbailout.staticGenerationBailout)("searchParams." + prop);
            }
        }
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/action-async-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "actionAsyncStorage", {
    enumerable: true,
    get: function() {
        return actionAsyncStorage;
    }
});
const _asynclocalstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)");
const actionAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/request-async-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "requestAsyncStorage", {
    enumerable: true,
    get: function() {
        return requestAsyncStorage;
    }
});
const _asynclocalstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)");
const requestAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_ae2fa0._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_810676.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_process_browser_a2df53.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_react_index_c4bfc2.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_build_polyfills_process_235e98.js",
    "included": [
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/0f475_dist_client_components_static-generation-searchparams-bailout-provider_b53fce.js",
    "included": [
      "[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript)"
    ]
  },
  "_next/static/chunks/0f475_dist_client_components_static-generation-searchparams-bailout-provider_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

(function() {
    var e = {
        229: function(e) {
            var t = e.exports = {};
            var r;
            var n;
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            (function() {
                try {
                    if (typeof setTimeout === "function") {
                        r = setTimeout;
                    } else {
                        r = defaultSetTimout;
                    }
                } catch (e) {
                    r = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === "function") {
                        n = clearTimeout;
                    } else {
                        n = defaultClearTimeout;
                    }
                } catch (e) {
                    n = defaultClearTimeout;
                }
            })();
            function runTimeout(e) {
                if (r === setTimeout) {
                    return setTimeout(e, 0);
                }
                if ((r === defaultSetTimout || !r) && setTimeout) {
                    r = setTimeout;
                    return setTimeout(e, 0);
                }
                try {
                    return r(e, 0);
                } catch (t) {
                    try {
                        return r.call(null, e, 0);
                    } catch (t) {
                        return r.call(this, e, 0);
                    }
                }
            }
            function runClearTimeout(e) {
                if (n === clearTimeout) {
                    return clearTimeout(e);
                }
                if ((n === defaultClearTimeout || !n) && clearTimeout) {
                    n = clearTimeout;
                    return clearTimeout(e);
                }
                try {
                    return n(e);
                } catch (t) {
                    try {
                        return n.call(null, e);
                    } catch (t) {
                        return n.call(this, e);
                    }
                }
            }
            var i = [];
            var o = false;
            var u;
            var a = -1;
            function cleanUpNextTick() {
                if (!o || !u) {
                    return;
                }
                o = false;
                if (u.length) {
                    i = u.concat(i);
                } else {
                    a = -1;
                }
                if (i.length) {
                    drainQueue();
                }
            }
            function drainQueue() {
                if (o) {
                    return;
                }
                var e = runTimeout(cleanUpNextTick);
                o = true;
                var t = i.length;
                while(t){
                    u = i;
                    i = [];
                    while(++a < t){
                        if (u) {
                            u[a].run();
                        }
                    }
                    a = -1;
                    t = i.length;
                }
                u = null;
                o = false;
                runClearTimeout(e);
            }
            t.nextTick = function(e) {
                var t = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for(var r = 1; r < arguments.length; r++){
                        t[r - 1] = arguments[r];
                    }
                }
                i.push(new Item(e, t));
                if (i.length === 1 && !o) {
                    runTimeout(drainQueue);
                }
            };
            function Item(e, t) {
                this.fun = e;
                this.array = t;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            t.title = "browser";
            t.browser = true;
            t.env = {};
            t.argv = [];
            t.version = "";
            t.versions = {};
            function noop() {}
            t.on = noop;
            t.addListener = noop;
            t.once = noop;
            t.off = noop;
            t.removeListener = noop;
            t.removeAllListeners = noop;
            t.emit = noop;
            t.prependListener = noop;
            t.prependOnceListener = noop;
            t.listeners = function(e) {
                return [];
            };
            t.binding = function(e) {
                throw new Error("process.binding is not supported");
            };
            t.cwd = function() {
                return "/";
            };
            t.chdir = function(e) {
                throw new Error("process.chdir is not supported");
            };
            t.umask = function() {
                return 0;
            };
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var i = t[r] = {
            exports: {}
        };
        var o = true;
        try {
            e[r](i, i.exports, __nccwpck_require__);
            o = false;
        } finally{
            if (o) delete t[r];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var r = __nccwpck_require__(229);
    module.exports = r;
})();

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/cjs/react.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = '18.3.0-canary-1cea38448-20230530';
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var ReactCurrentDispatcher$1 = {
            current: null
        };
        var ReactCurrentCache = {
            current: null
        };
        var ReactCurrentBatchConfig = {
            transition: null
        };
        var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false,
            didUsePromise: false
        };
        var ReactCurrentOwner = {
            current: null
        };
        var ReactDebugCurrentFrame$1 = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
            {
                currentExtraStackFrame = stack;
            }
        }
        {
            ReactDebugCurrentFrame$1.setExtraStackFrame = function(stack) {
                {
                    currentExtraStackFrame = stack;
                }
            };
            ReactDebugCurrentFrame$1.getCurrentStack = null;
            ReactDebugCurrentFrame$1.getStackAddendum = function() {
                var stack = '';
                if (currentExtraStackFrame) {
                    stack += currentExtraStackFrame;
                }
                var impl = ReactDebugCurrentFrame$1.getCurrentStack;
                if (impl) {
                    stack += impl() || '';
                }
                return stack;
            };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ContextRegistry$1 = {};
        var ReactSharedInternals = {
            ReactCurrentDispatcher: ReactCurrentDispatcher$1,
            ReactCurrentCache: ReactCurrentCache,
            ReactCurrentBatchConfig: ReactCurrentBatchConfig,
            ReactCurrentOwner: ReactCurrentOwner
        };
        {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame$1;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        {
            ReactSharedInternals.ContextRegistry = ContextRegistry$1;
        }
        function warn(format) {
            {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
            {
                var _constructor = publicInstance.constructor;
                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
                var warningKey = componentName + "." + callerName;
                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                    return;
                }
                error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
                didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
        }
        var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
                return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
                warnNoop(publicInstance, 'forceUpdate');
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                warnNoop(publicInstance, 'replaceState');
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                warnNoop(publicInstance, 'setState');
            }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
            Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
                throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
            }
            this.updater.enqueueSetState(this, partialState, callback, 'setState');
        };
        Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
        };
        {
            var deprecatedAPIs = {
                isMounted: [
                    'isMounted',
                    'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'
                ],
                replaceState: [
                    'replaceState',
                    'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'
                ]
            };
            var defineDeprecationWarning = function(methodName, info) {
                Object.defineProperty(Component.prototype, methodName, {
                    get: function() {
                        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                        return undefined;
                    }
                });
            };
            for(var fnName in deprecatedAPIs){
                if (deprecatedAPIs.hasOwnProperty(fnName)) {
                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                }
            }
        }
        function ComponentDummy() {}
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
            var refObject = {
                current: null
            };
            {
                Object.seal(refObject);
            }
            return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                    case REACT_SERVER_CONTEXT_TYPE:
                        {
                            var context2 = type;
                            return (context2.displayName || context2._globalName) + '.Provider';
                        }
                }
            }
            return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
                {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, 'key', {
                get: warnAboutAccessingKey,
                configurable: true
            });
        }
        function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
                {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, 'ref', {
                get: warnAboutAccessingRef,
                configurable: true
            });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        function ReactElement(type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        }
        function createElement$1(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self = null;
            var source = null;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    {
                        warnIfStringRefCannotBeAutoConverted(config);
                    }
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                self = config.__self === undefined ? null : config.__self;
                source = config.__source === undefined ? null : config.__source;
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                {
                    if (Object.freeze) {
                        Object.freeze(childArray);
                    }
                }
                props.children = childArray;
            }
            if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for(propName in defaultProps){
                    if (props[propName] === undefined) {
                        props[propName] = defaultProps[propName];
                    }
                }
            }
            {
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
        }
        function cloneElement$1(element, config, children) {
            if (element === null || element === undefined) {
                throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    owner = ReactCurrentOwner.current;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                var defaultProps;
                if (element.type && element.type.defaultProps) {
                    defaultProps = element.type.defaultProps;
                }
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        if (config[propName] === undefined && defaultProps !== undefined) {
                            props[propName] = defaultProps[propName];
                        } else {
                            props[propName] = config[propName];
                        }
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = '.';
        var SUBSEPARATOR = ':';
        function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
                '=': '=0',
                ':': '=2'
            };
            var escapedString = key.replace(escapeRegex, function(match) {
                return escaperLookup[match];
            });
            return '$' + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, '$&/');
        }
        function getElementKey(element, index) {
            if (typeof element === 'object' && element !== null && element.key != null) {
                {
                    checkKeyStringCoercion(element.key);
                }
                return escape('' + element.key);
            }
            return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === 'undefined' || type === 'boolean') {
                children = null;
            }
            var invokeCallback = false;
            if (children === null) {
                invokeCallback = true;
            } else {
                switch(type){
                    case 'string':
                    case 'number':
                        invokeCallback = true;
                        break;
                    case 'object':
                        switch(children.$$typeof){
                            case REACT_ELEMENT_TYPE:
                            case REACT_PORTAL_TYPE:
                                invokeCallback = true;
                        }
                }
            }
            if (invokeCallback) {
                var _child = children;
                var mappedChild = callback(_child);
                var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
                if (isArray(mappedChild)) {
                    var escapedChildKey = '';
                    if (childKey != null) {
                        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                    }
                    mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                        return c;
                    });
                } else if (mappedChild != null) {
                    if (isValidElement(mappedChild)) {
                        {
                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                                checkKeyStringCoercion(mappedChild.key);
                            }
                        }
                        mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                    }
                    array.push(mappedChild);
                }
                return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
                for(var i = 0; i < children.length; i++){
                    child = children[i];
                    nextName = nextNamePrefix + getElementKey(child, i);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var iterableChildren = children;
                    {
                        if (iteratorFn === iterableChildren.entries) {
                            if (!didWarnAboutMaps) {
                                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                            }
                            didWarnAboutMaps = true;
                        }
                    }
                    var iterator = iteratorFn.call(iterableChildren);
                    var step;
                    var ii = 0;
                    while(!(step = iterator.next()).done){
                        child = step.value;
                        nextName = nextNamePrefix + getElementKey(child, ii++);
                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                    }
                } else if (type === 'object') {
                    var childrenString = String(children);
                    throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
                }
            }
            return subtreeCount;
        }
        function mapChildren(children, func, context) {
            if (children == null) {
                return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, '', '', function(child) {
                return func.call(context, child, count++);
            });
            return result;
        }
        function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        }
        function toArray(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        }
        function onlyChild(children) {
            if (!isValidElement(children)) {
                throw new Error('React.Children.only expected to receive a single React element child.');
            }
            return children;
        }
        function createContext(defaultValue) {
            var context = {
                $$typeof: REACT_CONTEXT_TYPE,
                _currentValue: defaultValue,
                _currentValue2: defaultValue,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
            };
            context.Provider = {
                $$typeof: REACT_PROVIDER_TYPE,
                _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
                var Consumer = {
                    $$typeof: REACT_CONTEXT_TYPE,
                    _context: context
                };
                Object.defineProperties(Consumer, {
                    Provider: {
                        get: function() {
                            if (!hasWarnedAboutUsingConsumerProvider) {
                                hasWarnedAboutUsingConsumerProvider = true;
                                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                            }
                            return context.Provider;
                        },
                        set: function(_Provider) {
                            context.Provider = _Provider;
                        }
                    },
                    _currentValue: {
                        get: function() {
                            return context._currentValue;
                        },
                        set: function(_currentValue) {
                            context._currentValue = _currentValue;
                        }
                    },
                    _currentValue2: {
                        get: function() {
                            return context._currentValue2;
                        },
                        set: function(_currentValue2) {
                            context._currentValue2 = _currentValue2;
                        }
                    },
                    _threadCount: {
                        get: function() {
                            return context._threadCount;
                        },
                        set: function(_threadCount) {
                            context._threadCount = _threadCount;
                        }
                    },
                    Consumer: {
                        get: function() {
                            if (!hasWarnedAboutUsingNestedContextConsumers) {
                                hasWarnedAboutUsingNestedContextConsumers = true;
                                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                            }
                            return context.Consumer;
                        }
                    },
                    displayName: {
                        get: function() {
                            return context.displayName;
                        },
                        set: function(displayName) {
                            if (!hasWarnedAboutDisplayNameOnConsumer) {
                                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                                hasWarnedAboutDisplayNameOnConsumer = true;
                            }
                        }
                    }
                });
                context.Consumer = Consumer;
            }
            {
                context._currentRenderer = null;
                context._currentRenderer2 = null;
            }
            return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
                var ctor = payload._result;
                var thenable = ctor();
                thenable.then(function(moduleObject) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var resolved = payload;
                        resolved._status = Resolved;
                        resolved._result = moduleObject;
                    }
                }, function(error) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var rejected = payload;
                        rejected._status = Rejected;
                        rejected._result = error;
                    }
                });
                if (payload._status === Uninitialized) {
                    var pending = payload;
                    pending._status = Pending;
                    pending._result = thenable;
                }
            }
            if (payload._status === Resolved) {
                var moduleObject = payload._result;
                {
                    if (moduleObject === undefined) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
                    }
                }
                {
                    if (!('default' in moduleObject)) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
                    }
                }
                return moduleObject.default;
            } else {
                throw payload._result;
            }
        }
        function lazy(ctor) {
            var payload = {
                _status: Uninitialized,
                _result: ctor
            };
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: payload,
                _init: lazyInitializer
            };
            {
                var defaultProps;
                var propTypes;
                Object.defineProperties(lazyType, {
                    defaultProps: {
                        configurable: true,
                        get: function() {
                            return defaultProps;
                        },
                        set: function(newDefaultProps) {
                            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            defaultProps = newDefaultProps;
                            Object.defineProperty(lazyType, 'defaultProps', {
                                enumerable: true
                            });
                        }
                    },
                    propTypes: {
                        configurable: true,
                        get: function() {
                            return propTypes;
                        },
                        set: function(newPropTypes) {
                            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            propTypes = newPropTypes;
                            Object.defineProperty(lazyType, 'propTypes', {
                                enumerable: true
                            });
                        }
                    }
                });
            }
            return lazyType;
        }
        function forwardRef(render) {
            {
                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                    error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
                } else if (typeof render !== 'function') {
                    error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
                } else {
                    if (render.length !== 0 && render.length !== 2) {
                        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
                    }
                }
                if (render != null) {
                    if (render.defaultProps != null || render.propTypes != null) {
                        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
                    }
                }
            }
            var elementType = {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: render
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!render.name && !render.displayName) {
                            render.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function memo(type, compare) {
            {
                if (!isValidElementType(type)) {
                    error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
                }
            }
            var elementType = {
                $$typeof: REACT_MEMO_TYPE,
                type: type,
                compare: compare === undefined ? null : compare
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!type.name && !type.displayName) {
                            type.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var UNTERMINATED = 0;
        var TERMINATED = 1;
        var ERRORED = 2;
        function createCacheRoot() {
            return new WeakMap();
        }
        function createCacheNode() {
            return {
                s: UNTERMINATED,
                v: undefined,
                o: null,
                p: null
            };
        }
        function cache(fn) {
            return function() {
                var dispatcher = ReactCurrentCache.current;
                if (!dispatcher) {
                    return fn.apply(null, arguments);
                }
                var fnMap = dispatcher.getCacheForType(createCacheRoot);
                var fnNode = fnMap.get(fn);
                var cacheNode;
                if (fnNode === undefined) {
                    cacheNode = createCacheNode();
                    fnMap.set(fn, cacheNode);
                } else {
                    cacheNode = fnNode;
                }
                for(var i = 0, l = arguments.length; i < l; i++){
                    var arg = arguments[i];
                    if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {
                        var objectCache = cacheNode.o;
                        if (objectCache === null) {
                            cacheNode.o = objectCache = new WeakMap();
                        }
                        var objectNode = objectCache.get(arg);
                        if (objectNode === undefined) {
                            cacheNode = createCacheNode();
                            objectCache.set(arg, cacheNode);
                        } else {
                            cacheNode = objectNode;
                        }
                    } else {
                        var primitiveCache = cacheNode.p;
                        if (primitiveCache === null) {
                            cacheNode.p = primitiveCache = new Map();
                        }
                        var primitiveNode = primitiveCache.get(arg);
                        if (primitiveNode === undefined) {
                            cacheNode = createCacheNode();
                            primitiveCache.set(arg, cacheNode);
                        } else {
                            cacheNode = primitiveNode;
                        }
                    }
                }
                if (cacheNode.s === TERMINATED) {
                    return cacheNode.v;
                }
                if (cacheNode.s === ERRORED) {
                    throw cacheNode.v;
                }
                try {
                    var result = fn.apply(null, arguments);
                    var terminatedNode = cacheNode;
                    terminatedNode.s = TERMINATED;
                    terminatedNode.v = result;
                    return result;
                } catch (error) {
                    var erroredNode = cacheNode;
                    erroredNode.s = ERRORED;
                    erroredNode.v = error;
                    throw error;
                }
            };
        }
        function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher$1.current;
            {
                if (dispatcher === null) {
                    error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
                }
            }
            return dispatcher;
        }
        function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
                if (Context._context !== undefined) {
                    var realContext = Context._context;
                    if (realContext.Consumer === Context) {
                        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
                    } else if (realContext.Provider === Context) {
                        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
                    }
                }
            }
            return dispatcher.useContext(Context);
        }
        function useState(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
            {
                var dispatcher = resolveDispatcher();
                return dispatcher.useDebugValue(value, formatterFn);
            }
        }
        function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
        }
        function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        function useCacheRefresh() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCacheRefresh();
        }
        function use(usable) {
            var dispatcher = resolveDispatcher();
            return dispatcher.use(usable);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function() {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function() {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        } catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    } else {
                        try {
                            Fake.call();
                        } catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                } else {
                    try {
                        throw Error();
                    } catch (x) {
                        control = x;
                    }
                    fn();
                }
            } catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                        c--;
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        } catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement$1(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement$1(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement$1(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement$1(null);
                        }
                    }
                }
            }
        }
        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    setExtraStackFrame(stack);
                } else {
                    setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
                var name = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (name) {
                    return '\n\nCheck the render method of `' + name + '`.';
                }
            }
            return '';
        }
        function getSourceInfoErrorAddendum(source) {
            if (source !== undefined) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                var lineNumber = source.lineNumber;
                return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
            }
            return '';
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== undefined) {
                return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return '';
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                    info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
            }
            return info;
        }
        function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
                return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = '';
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
                setCurrentlyValidatingElement(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement(null);
            }
        }
        function validateChildKeys(node, parentType) {
            if (typeof node !== 'object' || !node) {
                return;
            }
            if (node.$$typeof === REACT_CLIENT_REFERENCE) ;
            else if (isArray(node)) {
                for(var i = 0; i < node.length; i++){
                    var child = node[i];
                    if (isValidElement(child)) {
                        validateExplicitKey(child, parentType);
                    }
                }
            } else if (isValidElement(node)) {
                if (node._store) {
                    node._store.validated = true;
                }
            } else {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === 'function') {
                    if (iteratorFn !== node.entries) {
                        var iterator = iteratorFn.call(node);
                        var step;
                        while(!(step = iterator.next()).done){
                            if (isValidElement(step.value)) {
                                validateExplicitKey(step.value, parentType);
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                if (type.$$typeof === REACT_CLIENT_REFERENCE) {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                } else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement(null);
                }
            }
        }
        function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                    info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendumForProps(props);
                if (sourceInfo) {
                    info += sourceInfo;
                } else {
                    info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                    typeString = 'null';
                } else if (isArray(type)) {
                    typeString = 'array';
                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                    typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                    info = ' Did you accidentally export a JSX literal instead of a component?';
                } else {
                    typeString = typeof type;
                }
                {
                    error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
            }
            var element = createElement$1.apply(this, arguments);
            if (element == null) {
                return element;
            }
            if (validType) {
                for(var i = 2; i < arguments.length; i++){
                    validateChildKeys(arguments[i], type);
                }
            }
            if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
            } else {
                validatePropTypes(element);
            }
            return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
                if (!didWarnAboutDeprecatedCreateFactory) {
                    didWarnAboutDeprecatedCreateFactory = true;
                    warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
                }
                Object.defineProperty(validatedFactory, 'type', {
                    enumerable: false,
                    get: function() {
                        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
                        Object.defineProperty(this, 'type', {
                            value: type
                        });
                        return type;
                    }
                });
            }
            return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement$1.apply(this, arguments);
            for(var i = 2; i < arguments.length; i++){
                validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
        }
        var ContextRegistry = ReactSharedInternals.ContextRegistry;
        function createServerContext(globalName, defaultValue) {
            var wasDefined = true;
            if (!ContextRegistry[globalName]) {
                wasDefined = false;
                var _context = {
                    $$typeof: REACT_SERVER_CONTEXT_TYPE,
                    _currentValue: defaultValue,
                    _currentValue2: defaultValue,
                    _defaultValue: defaultValue,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _globalName: globalName
                };
                _context.Provider = {
                    $$typeof: REACT_PROVIDER_TYPE,
                    _context: _context
                };
                {
                    var hasWarnedAboutUsingConsumer;
                    _context._currentRenderer = null;
                    _context._currentRenderer2 = null;
                    Object.defineProperties(_context, {
                        Consumer: {
                            get: function() {
                                if (!hasWarnedAboutUsingConsumer) {
                                    error('Consumer pattern is not supported by ReactServerContext');
                                    hasWarnedAboutUsingConsumer = true;
                                }
                                return null;
                            }
                        }
                    });
                }
                ContextRegistry[globalName] = _context;
            }
            var context = ContextRegistry[globalName];
            if (context._defaultValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                context._defaultValue = defaultValue;
                if (context._currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue = defaultValue;
                }
                if (context._currentValue2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue2 = defaultValue;
                }
            } else if (wasDefined) {
                throw new Error("ServerContext: " + globalName + " already defined");
            }
            return context;
        }
        function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
                ReactCurrentBatchConfig.transition._updatedFibers = new Set();
            }
            try {
                scope();
            } finally{
                ReactCurrentBatchConfig.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        currentTransition._updatedFibers.clear();
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                    }
                }
            }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
                try {
                    var requireString = ('require' + Math.random()).slice(0, 7);
                    var nodeRequire = module && module[requireString];
                    enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
                } catch (_err) {
                    enqueueTaskImpl = function(callback) {
                        {
                            if (didWarnAboutMessageChannel === false) {
                                didWarnAboutMessageChannel = true;
                                if (typeof MessageChannel === 'undefined') {
                                    error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
                                }
                            }
                        }
                        var channel = new MessageChannel();
                        channel.port1.onmessage = callback;
                        channel.port2.postMessage(undefined);
                    };
                }
            }
            return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
            {
                var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
                var prevActQueue = ReactCurrentActQueue.current;
                var prevActScopeDepth = actScopeDepth;
                actScopeDepth++;
                var queue = ReactCurrentActQueue.current = prevActQueue !== null ? prevActQueue : [];
                ReactCurrentActQueue.isBatchingLegacy = true;
                var result;
                var didAwaitActCall = false;
                try {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    result = callback();
                    var didScheduleLegacyUpdate = ReactCurrentActQueue.didScheduleLegacyUpdate;
                    if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {
                        flushActQueue(queue);
                    }
                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
                } catch (error) {
                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
                    popActScope(prevActQueue, prevActScopeDepth);
                    throw error;
                }
                if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
                    var thenable = result;
                    queueSeveralMicrotasks(function() {
                        if (!didAwaitActCall && !didWarnNoAwaitAct) {
                            didWarnNoAwaitAct = true;
                            error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
                        }
                    });
                    return {
                        then: function(resolve, reject) {
                            didAwaitActCall = true;
                            thenable.then(function(returnValue) {
                                popActScope(prevActQueue, prevActScopeDepth);
                                if (prevActScopeDepth === 0) {
                                    try {
                                        flushActQueue(queue);
                                        enqueueTask(function() {
                                            return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                        });
                                    } catch (error) {
                                        reject(error);
                                    }
                                } else {
                                    resolve(returnValue);
                                }
                            }, function(error) {
                                popActScope(prevActQueue, prevActScopeDepth);
                                reject(error);
                            });
                        }
                    };
                } else {
                    var returnValue = result;
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (prevActScopeDepth === 0) {
                        flushActQueue(queue);
                        if (queue.length !== 0) {
                            queueSeveralMicrotasks(function() {
                                if (!didAwaitActCall && !didWarnNoAwaitAct) {
                                    didWarnNoAwaitAct = true;
                                    error('A component suspended inside an `act` scope, but the ' + '`act` call was not awaited. When testing React ' + 'components that depend on asynchronous data, you must ' + 'await the result:\n\n' + 'await act(() => ...)');
                                }
                            });
                        }
                        ReactCurrentActQueue.current = null;
                    }
                    return {
                        then: function(resolve, reject) {
                            didAwaitActCall = true;
                            if (prevActScopeDepth === 0) {
                                ReactCurrentActQueue.current = queue;
                                enqueueTask(function() {
                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                });
                            } else {
                                resolve(returnValue);
                            }
                        }
                    };
                }
            }
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
            {
                if (prevActScopeDepth !== actScopeDepth - 1) {
                    error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
                }
                actScopeDepth = prevActScopeDepth;
            }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                    if (queue.length !== 0) {
                        try {
                            flushActQueue(queue);
                            enqueueTask(function() {
                                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                            });
                        } catch (error) {
                            reject(error);
                        }
                    } else {
                        ReactCurrentActQueue.current = null;
                        resolve(returnValue);
                    }
                } else {
                    resolve(returnValue);
                }
            }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
            {
                if (!isFlushing) {
                    isFlushing = true;
                    var i = 0;
                    try {
                        for(; i < queue.length; i++){
                            var callback = queue[i];
                            do {
                                ReactCurrentActQueue.didUsePromise = false;
                                var continuation = callback(false);
                                if (continuation !== null) {
                                    if (ReactCurrentActQueue.didUsePromise) {
                                        queue[i] = callback;
                                        queue.splice(0, i);
                                        return;
                                    }
                                    callback = continuation;
                                } else {
                                    break;
                                }
                            }while (true)
                        }
                        queue.length = 0;
                    } catch (error) {
                        queue.splice(0, i + 1);
                        throw error;
                    } finally{
                        isFlushing = false;
                    }
                }
            }
        }
        var queueSeveralMicrotasks = typeof queueMicrotask === 'function' ? function(callback) {
            queueMicrotask(function() {
                return queueMicrotask(callback);
            });
        } : enqueueTask;
        var createElement = createElementWithValidation;
        var cloneElement = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray,
            only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cache = cache;
        exports.cloneElement = cloneElement;
        exports.createContext = createContext;
        exports.createElement = createElement;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.createServerContext = createServerContext;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.unstable_useCacheRefresh = useCacheRefresh;
        exports.use = use;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        var ReactCurrentDispatcher$1 = {
            current: null
        };
        var ReactCurrentCache = {
            current: null
        };
        var ReactCurrentBatchConfig = {
            transition: null
        };
        var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false,
            didUsePromise: false
        };
        var ReactCurrentOwner = {
            current: null
        };
        var ReactDebugCurrentFrame$1 = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
            {
                currentExtraStackFrame = stack;
            }
        }
        {
            ReactDebugCurrentFrame$1.setExtraStackFrame = function(stack) {
                {
                    currentExtraStackFrame = stack;
                }
            };
            ReactDebugCurrentFrame$1.getCurrentStack = null;
            ReactDebugCurrentFrame$1.getStackAddendum = function() {
                var stack = '';
                if (currentExtraStackFrame) {
                    stack += currentExtraStackFrame;
                }
                var impl = ReactDebugCurrentFrame$1.getCurrentStack;
                if (impl) {
                    stack += impl() || '';
                }
                return stack;
            };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ContextRegistry$1 = {};
        var ReactSharedInternals = {
            ReactCurrentDispatcher: ReactCurrentDispatcher$1,
            ReactCurrentCache: ReactCurrentCache,
            ReactCurrentBatchConfig: ReactCurrentBatchConfig,
            ReactCurrentOwner: ReactCurrentOwner
        };
        {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame$1;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        {
            ReactSharedInternals.ContextRegistry = ContextRegistry$1;
        }
        function warn(format) {
            {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var assign = Object.assign;
        function createFetchCache() {
            return new Map();
        }
        var simpleCacheKey = '["GET",[],null,"follow",null,null,null,null]';
        function generateCacheKey(request) {
            return JSON.stringify([
                request.method,
                Array.from(request.headers.entries()),
                request.mode,
                request.redirect,
                request.credentials,
                request.referrer,
                request.referrerPolicy,
                request.integrity
            ]);
        }
        {
            if (typeof fetch === 'function') {
                var originalFetch = fetch;
                var cachedFetch = function fetch1(resource, options) {
                    var dispatcher = ReactCurrentCache.current;
                    if (!dispatcher) {
                        return originalFetch(resource, options);
                    }
                    if (options && options.signal && options.signal !== dispatcher.getCacheSignal()) {
                        return originalFetch(resource, options);
                    }
                    var url;
                    var cacheKey;
                    if (typeof resource === 'string' && !options) {
                        cacheKey = simpleCacheKey;
                        url = resource;
                    } else {
                        var request = typeof resource === 'string' || resource instanceof URL ? new Request(resource, options) : resource;
                        if (request.method !== 'GET' && request.method !== 'HEAD' || request.keepalive) {
                            return originalFetch(resource, options);
                        }
                        cacheKey = generateCacheKey(request);
                        url = request.url;
                    }
                    var cache = dispatcher.getCacheForType(createFetchCache);
                    var cacheEntries = cache.get(url);
                    var match;
                    if (cacheEntries === undefined) {
                        match = originalFetch(resource, options);
                        cache.set(url, [
                            cacheKey,
                            match
                        ]);
                    } else {
                        for(var i = 0, l = cacheEntries.length; i < l; i += 2){
                            var key = cacheEntries[i];
                            var value = cacheEntries[i + 1];
                            if (key === cacheKey) {
                                match = value;
                                return match.then(function(response) {
                                    return response.clone();
                                });
                            }
                        }
                        match = originalFetch(resource, options);
                        cacheEntries.push(cacheKey, match);
                    }
                    return match.then(function(response) {
                        return response.clone();
                    });
                };
                assign(cachedFetch, originalFetch);
                try {
                    fetch = cachedFetch;
                } catch (error1) {
                    try {
                        globalThis.fetch = cachedFetch;
                    } catch (error2) {
                        warn('React was unable to patch the fetch() function in this environment. ' + 'Suspensey APIs might not work correctly as a result.');
                    }
                }
            }
        }
        var ReactVersion = '18.3.0-canary-1cea38448-20230530';
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
            {
                var _constructor = publicInstance.constructor;
                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
                var warningKey = componentName + "." + callerName;
                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                    return;
                }
                error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
                didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
        }
        var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
                return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
                warnNoop(publicInstance, 'forceUpdate');
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                warnNoop(publicInstance, 'replaceState');
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                warnNoop(publicInstance, 'setState');
            }
        };
        var emptyObject = {};
        {
            Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
                throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
            }
            this.updater.enqueueSetState(this, partialState, callback, 'setState');
        };
        Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
        };
        {
            var deprecatedAPIs = {
                isMounted: [
                    'isMounted',
                    'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'
                ],
                replaceState: [
                    'replaceState',
                    'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'
                ]
            };
            var defineDeprecationWarning = function(methodName, info) {
                Object.defineProperty(Component.prototype, methodName, {
                    get: function() {
                        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                        return undefined;
                    }
                });
            };
            for(var fnName in deprecatedAPIs){
                if (deprecatedAPIs.hasOwnProperty(fnName)) {
                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                }
            }
        }
        function ComponentDummy() {}
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
            var refObject = {
                current: null
            };
            {
                Object.seal(refObject);
            }
            return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                    case REACT_SERVER_CONTEXT_TYPE:
                        {
                            var context2 = type;
                            return (context2.displayName || context2._globalName) + '.Provider';
                        }
                }
            }
            return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
                {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, 'key', {
                get: warnAboutAccessingKey,
                configurable: true
            });
        }
        function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
                {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, 'ref', {
                get: warnAboutAccessingRef,
                configurable: true
            });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        function ReactElement(type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        }
        function createElement$1(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self = null;
            var source = null;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    {
                        warnIfStringRefCannotBeAutoConverted(config);
                    }
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                self = config.__self === undefined ? null : config.__self;
                source = config.__source === undefined ? null : config.__source;
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                {
                    if (Object.freeze) {
                        Object.freeze(childArray);
                    }
                }
                props.children = childArray;
            }
            if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for(propName in defaultProps){
                    if (props[propName] === undefined) {
                        props[propName] = defaultProps[propName];
                    }
                }
            }
            {
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
        }
        function cloneElement$1(element, config, children) {
            if (element === null || element === undefined) {
                throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    owner = ReactCurrentOwner.current;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                var defaultProps;
                if (element.type && element.type.defaultProps) {
                    defaultProps = element.type.defaultProps;
                }
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        if (config[propName] === undefined && defaultProps !== undefined) {
                            props[propName] = defaultProps[propName];
                        } else {
                            props[propName] = config[propName];
                        }
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = '.';
        var SUBSEPARATOR = ':';
        function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
                '=': '=0',
                ':': '=2'
            };
            var escapedString = key.replace(escapeRegex, function(match) {
                return escaperLookup[match];
            });
            return '$' + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, '$&/');
        }
        function getElementKey(element, index) {
            if (typeof element === 'object' && element !== null && element.key != null) {
                {
                    checkKeyStringCoercion(element.key);
                }
                return escape('' + element.key);
            }
            return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === 'undefined' || type === 'boolean') {
                children = null;
            }
            var invokeCallback = false;
            if (children === null) {
                invokeCallback = true;
            } else {
                switch(type){
                    case 'string':
                    case 'number':
                        invokeCallback = true;
                        break;
                    case 'object':
                        switch(children.$$typeof){
                            case REACT_ELEMENT_TYPE:
                            case REACT_PORTAL_TYPE:
                                invokeCallback = true;
                        }
                }
            }
            if (invokeCallback) {
                var _child = children;
                var mappedChild = callback(_child);
                var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
                if (isArray(mappedChild)) {
                    var escapedChildKey = '';
                    if (childKey != null) {
                        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                    }
                    mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                        return c;
                    });
                } else if (mappedChild != null) {
                    if (isValidElement(mappedChild)) {
                        {
                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                                checkKeyStringCoercion(mappedChild.key);
                            }
                        }
                        mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                    }
                    array.push(mappedChild);
                }
                return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
                for(var i = 0; i < children.length; i++){
                    child = children[i];
                    nextName = nextNamePrefix + getElementKey(child, i);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var iterableChildren = children;
                    {
                        if (iteratorFn === iterableChildren.entries) {
                            if (!didWarnAboutMaps) {
                                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                            }
                            didWarnAboutMaps = true;
                        }
                    }
                    var iterator = iteratorFn.call(iterableChildren);
                    var step;
                    var ii = 0;
                    while(!(step = iterator.next()).done){
                        child = step.value;
                        nextName = nextNamePrefix + getElementKey(child, ii++);
                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                    }
                } else if (type === 'object') {
                    var childrenString = String(children);
                    throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
                }
            }
            return subtreeCount;
        }
        function mapChildren(children, func, context) {
            if (children == null) {
                return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, '', '', function(child) {
                return func.call(context, child, count++);
            });
            return result;
        }
        function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        }
        function toArray(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        }
        function onlyChild(children) {
            if (!isValidElement(children)) {
                throw new Error('React.Children.only expected to receive a single React element child.');
            }
            return children;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
                var ctor = payload._result;
                var thenable = ctor();
                thenable.then(function(moduleObject) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var resolved = payload;
                        resolved._status = Resolved;
                        resolved._result = moduleObject;
                    }
                }, function(error) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var rejected = payload;
                        rejected._status = Rejected;
                        rejected._result = error;
                    }
                });
                if (payload._status === Uninitialized) {
                    var pending = payload;
                    pending._status = Pending;
                    pending._result = thenable;
                }
            }
            if (payload._status === Resolved) {
                var moduleObject = payload._result;
                {
                    if (moduleObject === undefined) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
                    }
                }
                {
                    if (!('default' in moduleObject)) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
                    }
                }
                return moduleObject.default;
            } else {
                throw payload._result;
            }
        }
        function lazy(ctor) {
            var payload = {
                _status: Uninitialized,
                _result: ctor
            };
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: payload,
                _init: lazyInitializer
            };
            {
                var defaultProps;
                var propTypes;
                Object.defineProperties(lazyType, {
                    defaultProps: {
                        configurable: true,
                        get: function() {
                            return defaultProps;
                        },
                        set: function(newDefaultProps) {
                            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            defaultProps = newDefaultProps;
                            Object.defineProperty(lazyType, 'defaultProps', {
                                enumerable: true
                            });
                        }
                    },
                    propTypes: {
                        configurable: true,
                        get: function() {
                            return propTypes;
                        },
                        set: function(newPropTypes) {
                            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            propTypes = newPropTypes;
                            Object.defineProperty(lazyType, 'propTypes', {
                                enumerable: true
                            });
                        }
                    }
                });
            }
            return lazyType;
        }
        function forwardRef(render) {
            {
                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                    error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
                } else if (typeof render !== 'function') {
                    error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
                } else {
                    if (render.length !== 0 && render.length !== 2) {
                        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
                    }
                }
                if (render != null) {
                    if (render.defaultProps != null || render.propTypes != null) {
                        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
                    }
                }
            }
            var elementType = {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: render
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!render.name && !render.displayName) {
                            render.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function memo(type, compare) {
            {
                if (!isValidElementType(type)) {
                    error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
                }
            }
            var elementType = {
                $$typeof: REACT_MEMO_TYPE,
                type: type,
                compare: compare === undefined ? null : compare
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!type.name && !type.displayName) {
                            type.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var UNTERMINATED = 0;
        var TERMINATED = 1;
        var ERRORED = 2;
        function createCacheRoot() {
            return new WeakMap();
        }
        function createCacheNode() {
            return {
                s: UNTERMINATED,
                v: undefined,
                o: null,
                p: null
            };
        }
        function cache(fn) {
            return function() {
                var dispatcher = ReactCurrentCache.current;
                if (!dispatcher) {
                    return fn.apply(null, arguments);
                }
                var fnMap = dispatcher.getCacheForType(createCacheRoot);
                var fnNode = fnMap.get(fn);
                var cacheNode;
                if (fnNode === undefined) {
                    cacheNode = createCacheNode();
                    fnMap.set(fn, cacheNode);
                } else {
                    cacheNode = fnNode;
                }
                for(var i = 0, l = arguments.length; i < l; i++){
                    var arg = arguments[i];
                    if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {
                        var objectCache = cacheNode.o;
                        if (objectCache === null) {
                            cacheNode.o = objectCache = new WeakMap();
                        }
                        var objectNode = objectCache.get(arg);
                        if (objectNode === undefined) {
                            cacheNode = createCacheNode();
                            objectCache.set(arg, cacheNode);
                        } else {
                            cacheNode = objectNode;
                        }
                    } else {
                        var primitiveCache = cacheNode.p;
                        if (primitiveCache === null) {
                            cacheNode.p = primitiveCache = new Map();
                        }
                        var primitiveNode = primitiveCache.get(arg);
                        if (primitiveNode === undefined) {
                            cacheNode = createCacheNode();
                            primitiveCache.set(arg, cacheNode);
                        } else {
                            cacheNode = primitiveNode;
                        }
                    }
                }
                if (cacheNode.s === TERMINATED) {
                    return cacheNode.v;
                }
                if (cacheNode.s === ERRORED) {
                    throw cacheNode.v;
                }
                try {
                    var result = fn.apply(null, arguments);
                    var terminatedNode = cacheNode;
                    terminatedNode.s = TERMINATED;
                    terminatedNode.v = result;
                    return result;
                } catch (error) {
                    var erroredNode = cacheNode;
                    erroredNode.s = ERRORED;
                    erroredNode.v = error;
                    throw error;
                }
            };
        }
        function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher$1.current;
            {
                if (dispatcher === null) {
                    error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
                }
            }
            return dispatcher;
        }
        function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
                if (Context._context !== undefined) {
                    var realContext = Context._context;
                    if (realContext.Consumer === Context) {
                        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
                    } else if (realContext.Provider === Context) {
                        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
                    }
                }
            }
            return dispatcher.useContext(Context);
        }
        function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
        }
        function useDebugValue(value, formatterFn) {
            {
                var dispatcher = resolveDispatcher();
                return dispatcher.useDebugValue(value, formatterFn);
            }
        }
        function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
        }
        function use(usable) {
            var dispatcher = resolveDispatcher();
            return dispatcher.use(usable);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function() {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function() {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        } catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    } else {
                        try {
                            Fake.call();
                        } catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                } else {
                    try {
                        throw Error();
                    } catch (x) {
                        control = x;
                    }
                    fn();
                }
            } catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                        c--;
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        } catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement$1(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement$1(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement$1(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement$1(null);
                        }
                    }
                }
            }
        }
        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    setExtraStackFrame(stack);
                } else {
                    setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
                var name = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (name) {
                    return '\n\nCheck the render method of `' + name + '`.';
                }
            }
            return '';
        }
        function getSourceInfoErrorAddendum(source) {
            if (source !== undefined) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                var lineNumber = source.lineNumber;
                return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
            }
            return '';
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== undefined) {
                return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return '';
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                    info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
            }
            return info;
        }
        function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
                return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = '';
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
                setCurrentlyValidatingElement(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement(null);
            }
        }
        function validateChildKeys(node, parentType) {
            if (typeof node !== 'object' || !node) {
                return;
            }
            if (node.$$typeof === REACT_CLIENT_REFERENCE) ;
            else if (isArray(node)) {
                for(var i = 0; i < node.length; i++){
                    var child = node[i];
                    if (isValidElement(child)) {
                        validateExplicitKey(child, parentType);
                    }
                }
            } else if (isValidElement(node)) {
                if (node._store) {
                    node._store.validated = true;
                }
            } else {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === 'function') {
                    if (iteratorFn !== node.entries) {
                        var iterator = iteratorFn.call(node);
                        var step;
                        while(!(step = iterator.next()).done){
                            if (isValidElement(step.value)) {
                                validateExplicitKey(step.value, parentType);
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                if (type.$$typeof === REACT_CLIENT_REFERENCE) {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                } else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement(null);
                }
            }
        }
        function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                    info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendumForProps(props);
                if (sourceInfo) {
                    info += sourceInfo;
                } else {
                    info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                    typeString = 'null';
                } else if (isArray(type)) {
                    typeString = 'array';
                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                    typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                    info = ' Did you accidentally export a JSX literal instead of a component?';
                } else {
                    typeString = typeof type;
                }
                {
                    error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
            }
            var element = createElement$1.apply(this, arguments);
            if (element == null) {
                return element;
            }
            if (validType) {
                for(var i = 2; i < arguments.length; i++){
                    validateChildKeys(arguments[i], type);
                }
            }
            if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
            } else {
                validatePropTypes(element);
            }
            return element;
        }
        function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement$1.apply(this, arguments);
            for(var i = 2; i < arguments.length; i++){
                validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
        }
        var ContextRegistry = ReactSharedInternals.ContextRegistry;
        function createServerContext(globalName, defaultValue) {
            var wasDefined = true;
            if (!ContextRegistry[globalName]) {
                wasDefined = false;
                var _context = {
                    $$typeof: REACT_SERVER_CONTEXT_TYPE,
                    _currentValue: defaultValue,
                    _currentValue2: defaultValue,
                    _defaultValue: defaultValue,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _globalName: globalName
                };
                _context.Provider = {
                    $$typeof: REACT_PROVIDER_TYPE,
                    _context: _context
                };
                {
                    var hasWarnedAboutUsingConsumer;
                    _context._currentRenderer = null;
                    _context._currentRenderer2 = null;
                    Object.defineProperties(_context, {
                        Consumer: {
                            get: function() {
                                if (!hasWarnedAboutUsingConsumer) {
                                    error('Consumer pattern is not supported by ReactServerContext');
                                    hasWarnedAboutUsingConsumer = true;
                                }
                                return null;
                            }
                        }
                    });
                }
                ContextRegistry[globalName] = _context;
            }
            var context = ContextRegistry[globalName];
            if (context._defaultValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                context._defaultValue = defaultValue;
                if (context._currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue = defaultValue;
                }
                if (context._currentValue2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue2 = defaultValue;
                }
            } else if (wasDefined) {
                throw new Error("ServerContext: " + globalName + " already defined");
            }
            return context;
        }
        function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
                ReactCurrentBatchConfig.transition._updatedFibers = new Set();
            }
            try {
                scope();
            } finally{
                ReactCurrentBatchConfig.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        currentTransition._updatedFibers.clear();
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                    }
                }
            }
        }
        var createElement = createElementWithValidation;
        var cloneElement = cloneElementWithValidation;
        var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray,
            only: onlyChild
        };
        exports.Children = Children;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cache = cache;
        exports.cloneElement = cloneElement;
        exports.createElement = createElement;
        exports.createRef = createRef;
        exports.createServerContext = createServerContext;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.use = use;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useId = useId;
        exports.useMemo = useMemo;
        exports.version = ReactVersion;
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/react.shared-subset.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/react.shared-subset.js (ecmascript, rsc)");
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                    case REACT_SERVER_CONTEXT_TYPE:
                        {
                            var context2 = type;
                            return (context2.displayName || context2._globalName) + '.Provider';
                        }
                }
            }
            return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function() {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function() {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        } catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    } else {
                        try {
                            Fake.call();
                        } catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                } else {
                    try {
                        throw Error();
                    } catch (x) {
                        control = x;
                    }
                    fn();
                }
            } catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                        c--;
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        } catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement$1(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement$1(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement$1(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement$1(null);
                        }
                    }
                }
            }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        function defineKeyPropWarningGetter(props, displayName) {
            {
                var warnAboutAccessingKey = function() {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                };
                warnAboutAccessingKey.isReactWarning = true;
                Object.defineProperty(props, 'key', {
                    get: warnAboutAccessingKey,
                    configurable: true
                });
            }
        }
        function defineRefPropWarningGetter(props, displayName) {
            {
                var warnAboutAccessingRef = function() {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                };
                warnAboutAccessingRef.isReactWarning = true;
                Object.defineProperty(props, 'ref', {
                    get: warnAboutAccessingRef,
                    configurable: true
                });
            }
        }
        function ReactElement(type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        }
        function jsxDEV$1(type, config, maybeKey, source, self) {
            {
                var propName;
                var props = {};
                var key = null;
                var ref = null;
                if (maybeKey !== undefined) {
                    {
                        checkKeyStringCoercion(maybeKey);
                    }
                    key = '' + maybeKey;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                if (hasValidRef(config)) {
                    ref = config.ref;
                    warnIfStringRefCannotBeAutoConverted(config, self);
                }
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
                if (type && type.defaultProps) {
                    var defaultProps = type.defaultProps;
                    for(propName in defaultProps){
                        if (props[propName] === undefined) {
                            props[propName] = defaultProps[propName];
                        }
                    }
                }
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);
            }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame.setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
            {
                return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
        }
        function getDeclarationErrorAddendum() {
            {
                if (ReactCurrentOwner.current) {
                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (name) {
                        return '\n\nCheck the render method of `' + name + '`.';
                    }
                }
                return '';
            }
        }
        function getSourceInfoErrorAddendum(source) {
            {
                if (source !== undefined) {
                    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                    var lineNumber = source.lineNumber;
                    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
                }
                return '';
            }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            {
                var info = getDeclarationErrorAddendum();
                if (!info) {
                    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                    if (parentName) {
                        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                    }
                }
                return info;
            }
        }
        function validateExplicitKey(element, parentType) {
            {
                if (!element._store || element._store.validated || element.key != null) {
                    return;
                }
                element._store.validated = true;
                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                    return;
                }
                ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                var childOwner = '';
                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                    childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
                }
                setCurrentlyValidatingElement(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement(null);
            }
        }
        function validateChildKeys(node, parentType) {
            {
                if (typeof node !== 'object' || !node) {
                    return;
                }
                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;
                else if (isArray(node)) {
                    for(var i = 0; i < node.length; i++){
                        var child = node[i];
                        if (isValidElement(child)) {
                            validateExplicitKey(child, parentType);
                        }
                    }
                } else if (isValidElement(node)) {
                    if (node._store) {
                        node._store.validated = true;
                    }
                } else {
                    var iteratorFn = getIteratorFn(node);
                    if (typeof iteratorFn === 'function') {
                        if (iteratorFn !== node.entries) {
                            var iterator = iteratorFn.call(node);
                            var step;
                            while(!(step = iterator.next()).done){
                                if (isValidElement(step.value)) {
                                    validateExplicitKey(step.value, parentType);
                                }
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                if (type.$$typeof === REACT_CLIENT_REFERENCE) {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                } else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement(null);
                }
            }
        }
        var didWarnAboutKeySpread = {};
        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
            {
                var validType = isValidElementType(type);
                if (!validType) {
                    var info = '';
                    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                    }
                    var sourceInfo = getSourceInfoErrorAddendum(source);
                    if (sourceInfo) {
                        info += sourceInfo;
                    } else {
                        info += getDeclarationErrorAddendum();
                    }
                    var typeString;
                    if (type === null) {
                        typeString = 'null';
                    } else if (isArray(type)) {
                        typeString = 'array';
                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                        info = ' Did you accidentally export a JSX literal instead of a component?';
                    } else {
                        typeString = typeof type;
                    }
                    error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
                var element = jsxDEV$1(type, props, key, source, self);
                if (element == null) {
                    return element;
                }
                if (validType) {
                    var children = props.children;
                    if (children !== undefined) {
                        if (isStaticChildren) {
                            if (isArray(children)) {
                                for(var i = 0; i < children.length; i++){
                                    validateChildKeys(children[i], type);
                                }
                                if (Object.freeze) {
                                    Object.freeze(children);
                                }
                            } else {
                                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
                            }
                        } else {
                            validateChildKeys(children, type);
                        }
                    }
                }
                if (hasOwnProperty.call(props, 'key')) {
                    var componentName = getComponentNameFromType(type);
                    var keys = Object.keys(props).filter(function(k) {
                        return k !== 'key';
                    });
                    var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';
                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
                        error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                        didWarnAboutKeySpread[componentName + beforeExample] = true;
                    }
                }
                if (type === REACT_FRAGMENT_TYPE) {
                    validateFragmentProps(element);
                } else {
                    validatePropTypes(element);
                }
                return element;
            }
        }
        var jsxDEV = jsxWithValidation;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsxDEV = jsxDEV;
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        var ReactVersion = '18.3.0-canary-1cea38448-20230530';
        var Internals = {
            usingClientEntryPoint: false,
            Events: null,
            Dispatcher: {
                current: null
            }
        };
        var Dispatcher = Internals.Dispatcher;
        function prefetchDNS(href) {
            var passedOptionArg;
            {
                if (arguments[1] !== undefined) {
                    passedOptionArg = arguments[1];
                }
            }
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                {
                    if (passedOptionArg !== undefined) {
                        dispatcher.prefetchDNS(href, passedOptionArg);
                    } else {
                        dispatcher.prefetchDNS(href);
                    }
                }
            }
        }
        function preconnect(href, options) {
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                dispatcher.preconnect(href, options);
            }
        }
        function preload(href, options) {
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                dispatcher.preload(href, options);
            }
        }
        function preinit(href, options) {
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                dispatcher.preinit(href, options);
            }
        }
        function useFormStatus() {
            {
                throw new Error('Not implemented.');
            }
        }
        function createPortal() {
            throw new Error('createPortal was called on the server. Portals are not currently' + ' supported on the server. Update your program to conditionally call' + ' createPortal on the client only.');
        }
        function flushSync() {
            throw new Error('flushSync was called on the server. This is likely caused by a' + ' function being called during render or in module scope that was' + ' intended to be called from an effect or event handler. Update your' + ' to not call flushSync no the server.');
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal;
        exports.experimental_useFormStatus = useFormStatus;
        exports.flushSync = flushSync;
        exports.preconnect = preconnect;
        exports.prefetchDNS = prefetchDNS;
        exports.preinit = preinit;
        exports.preload = preload;
        exports.version = ReactVersion;
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, rsc)");
        var ReactDOM = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, rsc)");
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        function scheduleWork(callback) {
            setTimeout(callback, 0);
        }
        var VIEW_SIZE = 512;
        var currentView = null;
        var writtenBytes = 0;
        function beginWriting(destination) {
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
        }
        function writeChunk(destination, chunk) {
            if (chunk.length === 0) {
                return;
            }
            if (chunk.length > VIEW_SIZE) {
                {
                    if (precomputedChunkSet.has(chunk)) {
                        error('A large precomputed chunk was passed to writeChunk without being copied.' + ' Large chunks get enqueued directly and are not copied. This is incompatible with precomputed chunks because you cannot enqueue the same precomputed chunk twice.' + ' Use "cloneChunk" to make a copy of this large precomputed chunk before writing it. This is a bug in React.');
                    }
                }
                if (writtenBytes > 0) {
                    destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                    currentView = new Uint8Array(VIEW_SIZE);
                    writtenBytes = 0;
                }
                destination.enqueue(chunk);
                return;
            }
            var bytesToWrite = chunk;
            var allowableBytes = currentView.length - writtenBytes;
            if (allowableBytes < bytesToWrite.length) {
                if (allowableBytes === 0) {
                    destination.enqueue(currentView);
                } else {
                    currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
                    destination.enqueue(currentView);
                    bytesToWrite = bytesToWrite.subarray(allowableBytes);
                }
                currentView = new Uint8Array(VIEW_SIZE);
                writtenBytes = 0;
            }
            currentView.set(bytesToWrite, writtenBytes);
            writtenBytes += bytesToWrite.length;
        }
        function writeChunkAndReturn(destination, chunk) {
            writeChunk(destination, chunk);
            return true;
        }
        function completeWriting(destination) {
            if (currentView && writtenBytes > 0) {
                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                currentView = null;
                writtenBytes = 0;
            }
        }
        function close$1(destination) {
            destination.close();
        }
        var textEncoder = new TextEncoder();
        function stringToChunk(content) {
            return textEncoder.encode(content);
        }
        var precomputedChunkSet = new Set();
        function closeWithError(destination, error) {
            if (typeof destination.error === 'function') {
                destination.error(error);
            } else {
                destination.close();
            }
        }
        var CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference');
        var SERVER_REFERENCE_TAG = Symbol.for('react.server.reference');
        function getClientReferenceKey(reference) {
            return reference.$$async ? reference.$$id + '#async' : reference.$$id;
        }
        function isClientReference(reference) {
            return reference.$$typeof === CLIENT_REFERENCE_TAG;
        }
        function isServerReference(reference) {
            return reference.$$typeof === SERVER_REFERENCE_TAG;
        }
        function resolveClientReferenceMetadata(config, clientReference) {
            var modulePath = clientReference.$$id;
            var name = '';
            var resolvedModuleData = config[modulePath];
            if (resolvedModuleData) {
                name = resolvedModuleData.name;
            } else {
                var idx = modulePath.lastIndexOf('#');
                if (idx !== -1) {
                    name = modulePath.slice(idx + 1);
                    resolvedModuleData = config[modulePath.slice(0, idx)];
                }
                if (!resolvedModuleData) {
                    throw new Error('Could not find the module "' + modulePath + '" in the React Client Manifest. ' + 'This is probably a bug in the React Server Components bundler.');
                }
            }
            return {
                id: resolvedModuleData.id,
                chunks: resolvedModuleData.chunks,
                name: name,
                async: !!clientReference.$$async
            };
        }
        function getServerReferenceId(config, serverReference) {
            return serverReference.$$id;
        }
        function getServerReferenceBoundArguments(config, serverReference) {
            return serverReference.$$bound;
        }
        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var ReactDOMFlightServerDispatcher = {
            prefetchDNS: prefetchDNS,
            preconnect: preconnect,
            preload: preload,
            preinit: preinit
        };
        function prefetchDNS(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var key = 'D' + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        if (options) {
                            emitHint(request, 'D', [
                                href,
                                options
                            ]);
                        } else {
                            emitHint(request, 'D', href);
                        }
                    }
                }
            }
        }
        function preconnect(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var crossOrigin = options == null || typeof options.crossOrigin !== 'string' ? null : options.crossOrigin === 'use-credentials' ? 'use-credentials' : '';
                        var key = "C" + (crossOrigin === null ? 'null' : crossOrigin) + "|" + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        if (options) {
                            emitHint(request, 'C', [
                                href,
                                options
                            ]);
                        } else {
                            emitHint(request, 'C', href);
                        }
                    }
                }
            }
        }
        function preload(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var key = 'L' + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        emitHint(request, 'L', [
                            href,
                            options
                        ]);
                    }
                }
            }
        }
        function preinit(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var key = 'I' + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        emitHint(request, 'I', [
                            href,
                            options
                        ]);
                    }
                }
            }
        }
        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;
        function prepareHostDispatcher() {
            ReactDOMCurrentDispatcher.current = ReactDOMFlightServerDispatcher;
        }
        function createHints() {
            return new Set();
        }
        var supportsRequestStorage = typeof AsyncLocalStorage === 'function';
        var requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null;
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var rendererSigil;
        {
            rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
            {
                prev.context._currentValue = prev.parentValue;
            }
        }
        function pushNode(next) {
            {
                next.context._currentValue = next.value;
            }
        }
        function popToNearestCommonAncestor(prev, next) {
            if (prev === next) ;
            else {
                popNode(prev);
                var parentPrev = prev.parent;
                var parentNext = next.parent;
                if (parentPrev === null) {
                    if (parentNext !== null) {
                        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                    }
                } else {
                    if (parentNext === null) {
                        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                    }
                    popToNearestCommonAncestor(parentPrev, parentNext);
                    pushNode(next);
                }
            }
        }
        function popAllPrevious(prev) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev !== null) {
                popAllPrevious(parentPrev);
            }
        }
        function pushAllNext(next) {
            var parentNext = next.parent;
            if (parentNext !== null) {
                pushAllNext(parentNext);
            }
            pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev === null) {
                throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
            }
            if (parentPrev.depth === next.depth) {
                popToNearestCommonAncestor(parentPrev, next);
            } else {
                popPreviousToCommonLevel(parentPrev, next);
            }
        }
        function popNextToCommonLevel(prev, next) {
            var parentNext = next.parent;
            if (parentNext === null) {
                throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
            }
            if (prev.depth === parentNext.depth) {
                popToNearestCommonAncestor(prev, parentNext);
            } else {
                popNextToCommonLevel(prev, parentNext);
            }
            pushNode(next);
        }
        function switchContext(newSnapshot) {
            var prev = currentActiveSnapshot;
            var next = newSnapshot;
            if (prev !== next) {
                if (prev === null) {
                    pushAllNext(next);
                } else if (next === null) {
                    popAllPrevious(prev);
                } else if (prev.depth === next.depth) {
                    popToNearestCommonAncestor(prev, next);
                } else if (prev.depth > next.depth) {
                    popPreviousToCommonLevel(prev, next);
                } else {
                    popNextToCommonLevel(prev, next);
                }
                currentActiveSnapshot = next;
            }
        }
        function pushProvider(context, nextValue) {
            var prevValue;
            {
                prevValue = context._currentValue;
                context._currentValue = nextValue;
                {
                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
                    }
                    context._currentRenderer = rendererSigil;
                }
            }
            var prevNode = currentActiveSnapshot;
            var newNode = {
                parent: prevNode,
                depth: prevNode === null ? 0 : prevNode.depth + 1,
                context: context,
                parentValue: prevValue,
                value: nextValue
            };
            currentActiveSnapshot = newNode;
            return newNode;
        }
        function popProvider() {
            var prevSnapshot = currentActiveSnapshot;
            if (prevSnapshot === null) {
                throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
            }
            {
                var value = prevSnapshot.parentValue;
                if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
                } else {
                    prevSnapshot.context._currentValue = value;
                }
            }
            return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
            return currentActiveSnapshot;
        }
        function readContext$1(context) {
            var value = context._currentValue;
            return value;
        }
        var SuspenseException = new Error("Suspense Exception: This is not a real error! It's an implementation " + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\n\n' + 'To handle async errors, wrap your component in an error boundary, or ' + "call the promise's `.catch` method and pass the result to `use`");
        function createThenableState() {
            return [];
        }
        function noop() {}
        function trackUsedThenable(thenableState, thenable, index) {
            var previous = thenableState[index];
            if (previous === undefined) {
                thenableState.push(thenable);
            } else {
                if (previous !== thenable) {
                    thenable.then(noop, noop);
                    thenable = previous;
                }
            }
            switch(thenable.status){
                case 'fulfilled':
                    {
                        var fulfilledValue = thenable.value;
                        return fulfilledValue;
                    }
                case 'rejected':
                    {
                        var rejectedError = thenable.reason;
                        throw rejectedError;
                    }
                default:
                    {
                        if (typeof thenable.status === 'string') ;
                        else {
                            var pendingThenable = thenable;
                            pendingThenable.status = 'pending';
                            pendingThenable.then(function(fulfilledValue) {
                                if (thenable.status === 'pending') {
                                    var fulfilledThenable = thenable;
                                    fulfilledThenable.status = 'fulfilled';
                                    fulfilledThenable.value = fulfilledValue;
                                }
                            }, function(error) {
                                if (thenable.status === 'pending') {
                                    var rejectedThenable = thenable;
                                    rejectedThenable.status = 'rejected';
                                    rejectedThenable.reason = error;
                                }
                            });
                            switch(thenable.status){
                                case 'fulfilled':
                                    {
                                        var fulfilledThenable = thenable;
                                        return fulfilledThenable.value;
                                    }
                                case 'rejected':
                                    {
                                        var rejectedThenable = thenable;
                                        throw rejectedThenable.reason;
                                    }
                            }
                        }
                        suspendedThenable = thenable;
                        throw SuspenseException;
                    }
            }
        }
        var suspendedThenable = null;
        function getSuspendedThenable() {
            if (suspendedThenable === null) {
                throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');
            }
            var thenable = suspendedThenable;
            suspendedThenable = null;
            return thenable;
        }
        var currentRequest$1 = null;
        var thenableIndexCounter = 0;
        var thenableState = null;
        function prepareToUseHooksForRequest(request) {
            currentRequest$1 = request;
        }
        function resetHooksForRequest() {
            currentRequest$1 = null;
        }
        function prepareToUseHooksForComponent(prevThenableState) {
            thenableIndexCounter = 0;
            thenableState = prevThenableState;
        }
        function getThenableStateAfterSuspending() {
            var state = thenableState;
            thenableState = null;
            return state;
        }
        function readContext(context) {
            {
                if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {
                    if (isClientReference(context)) {
                        error('Cannot read a Client Context from a Server Component.');
                    } else {
                        error('Only createServerContext is supported in Server Components.');
                    }
                }
                if (currentRequest$1 === null) {
                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                }
            }
            return readContext$1(context);
        }
        var HooksDispatcher = {
            useMemo: function(nextCreate) {
                return nextCreate();
            },
            useCallback: function(callback) {
                return callback;
            },
            useDebugValue: function() {},
            useDeferredValue: unsupportedHook,
            useTransition: unsupportedHook,
            readContext: readContext,
            useContext: readContext,
            useReducer: unsupportedHook,
            useRef: unsupportedHook,
            useState: unsupportedHook,
            useInsertionEffect: unsupportedHook,
            useLayoutEffect: unsupportedHook,
            useImperativeHandle: unsupportedHook,
            useEffect: unsupportedHook,
            useId: useId,
            useMutableSource: unsupportedHook,
            useSyncExternalStore: unsupportedHook,
            useCacheRefresh: function() {
                return unsupportedRefresh;
            },
            useMemoCache: function(size) {
                var data = new Array(size);
                for(var i = 0; i < size; i++){
                    data[i] = REACT_MEMO_CACHE_SENTINEL;
                }
                return data;
            },
            use: use
        };
        function unsupportedHook() {
            throw new Error('This Hook is not supported in Server Components.');
        }
        function unsupportedRefresh() {
            throw new Error('Refreshing the cache is not supported in Server Components.');
        }
        function useId() {
            if (currentRequest$1 === null) {
                throw new Error('useId can only be used while React is rendering');
            }
            var id = currentRequest$1.identifierCount++;
            return ':' + currentRequest$1.identifierPrefix + 'S' + id.toString(32) + ':';
        }
        function use(usable) {
            if (usable !== null && typeof usable === 'object' || typeof usable === 'function') {
                if (typeof usable.then === 'function') {
                    var thenable = usable;
                    var index = thenableIndexCounter;
                    thenableIndexCounter += 1;
                    if (thenableState === null) {
                        thenableState = createThenableState();
                    }
                    return trackUsedThenable(thenableState, thenable, index);
                } else if (usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {
                    var context = usable;
                    return readContext(context);
                }
            }
            {
                if (isClientReference(usable)) {
                    error('Cannot use() an already resolved Client Reference.');
                }
            }
            throw new Error('An unsupported type was passed to use(): ' + String(usable));
        }
        function createSignal() {
            return new AbortController().signal;
        }
        function resolveCache() {
            var request = resolveRequest();
            if (request) {
                return getCache(request);
            }
            return new Map();
        }
        var DefaultCacheDispatcher = {
            getCacheSignal: function() {
                var cache = resolveCache();
                var entry = cache.get(createSignal);
                if (entry === undefined) {
                    entry = createSignal();
                    cache.set(createSignal, entry);
                }
                return entry;
            },
            getCacheForType: function(resourceType) {
                var cache = resolveCache();
                var entry = cache.get(resourceType);
                if (entry === undefined) {
                    entry = resourceType();
                    cache.set(resourceType, entry);
                }
                return entry;
            }
        };
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        var jsxPropsParents = new WeakMap();
        var jsxChildrenParents = new WeakMap();
        function isObjectPrototype(object) {
            if (!object) {
                return false;
            }
            var ObjectPrototype = Object.prototype;
            if (object === ObjectPrototype) {
                return true;
            }
            if (Object.getPrototypeOf(object)) {
                return false;
            }
            var names = Object.getOwnPropertyNames(object);
            for(var i = 0; i < names.length; i++){
                if (!(names[i] in ObjectPrototype)) {
                    return false;
                }
            }
            return true;
        }
        function isSimpleObject(object) {
            if (!isObjectPrototype(Object.getPrototypeOf(object))) {
                return false;
            }
            var names = Object.getOwnPropertyNames(object);
            for(var i = 0; i < names.length; i++){
                var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
                if (!descriptor) {
                    return false;
                }
                if (!descriptor.enumerable) {
                    if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
                        continue;
                    }
                    return false;
                }
            }
            return true;
        }
        function objectName(object) {
            var name = Object.prototype.toString.call(object);
            return name.replace(/^\[object (.*)\]$/, function(m, p0) {
                return p0;
            });
        }
        function describeKeyForErrorMessage(key) {
            var encodedKey = JSON.stringify(key);
            return '"' + key + '"' === encodedKey ? key : encodedKey;
        }
        function describeValueForErrorMessage(value) {
            switch(typeof value){
                case 'string':
                    {
                        return JSON.stringify(value.length <= 10 ? value : value.slice(0, 10) + '...');
                    }
                case 'object':
                    {
                        if (isArray(value)) {
                            return '[...]';
                        }
                        var name = objectName(value);
                        if (name === 'Object') {
                            return '{...}';
                        }
                        return name;
                    }
                case 'function':
                    return 'function';
                default:
                    return String(value);
            }
        }
        function describeElementType(type) {
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeElementType(type.render);
                    case REACT_MEMO_TYPE:
                        return describeElementType(type.type);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeElementType(init(payload));
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        function describeObjectForErrorMessage(objectOrArray, expandedName) {
            var objKind = objectName(objectOrArray);
            if (objKind !== 'Object' && objKind !== 'Array') {
                return objKind;
            }
            var str = '';
            var start = -1;
            var length = 0;
            if (isArray(objectOrArray)) {
                if (jsxChildrenParents.has(objectOrArray)) {
                    var type = jsxChildrenParents.get(objectOrArray);
                    str = '<' + describeElementType(type) + '>';
                    var array = objectOrArray;
                    for(var i = 0; i < array.length; i++){
                        var value = array[i];
                        var substr = void 0;
                        if (typeof value === 'string') {
                            substr = value;
                        } else if (typeof value === 'object' && value !== null) {
                            substr = '{' + describeObjectForErrorMessage(value) + '}';
                        } else {
                            substr = '{' + describeValueForErrorMessage(value) + '}';
                        }
                        if ('' + i === expandedName) {
                            start = str.length;
                            length = substr.length;
                            str += substr;
                        } else if (substr.length < 15 && str.length + substr.length < 40) {
                            str += substr;
                        } else {
                            str += '{...}';
                        }
                    }
                    str += '</' + describeElementType(type) + '>';
                } else {
                    str = '[';
                    var _array = objectOrArray;
                    for(var _i = 0; _i < _array.length; _i++){
                        if (_i > 0) {
                            str += ', ';
                        }
                        var _value = _array[_i];
                        var _substr = void 0;
                        if (typeof _value === 'object' && _value !== null) {
                            _substr = describeObjectForErrorMessage(_value);
                        } else {
                            _substr = describeValueForErrorMessage(_value);
                        }
                        if ('' + _i === expandedName) {
                            start = str.length;
                            length = _substr.length;
                            str += _substr;
                        } else if (_substr.length < 10 && str.length + _substr.length < 40) {
                            str += _substr;
                        } else {
                            str += '...';
                        }
                    }
                    str += ']';
                }
            } else {
                if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {
                    str = '<' + describeElementType(objectOrArray.type) + '/>';
                } else if (jsxPropsParents.has(objectOrArray)) {
                    var _type = jsxPropsParents.get(objectOrArray);
                    str = '<' + (describeElementType(_type) || '...');
                    var object = objectOrArray;
                    var names = Object.keys(object);
                    for(var _i2 = 0; _i2 < names.length; _i2++){
                        str += ' ';
                        var name = names[_i2];
                        str += describeKeyForErrorMessage(name) + '=';
                        var _value2 = object[name];
                        var _substr2 = void 0;
                        if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
                            _substr2 = describeObjectForErrorMessage(_value2);
                        } else {
                            _substr2 = describeValueForErrorMessage(_value2);
                        }
                        if (typeof _value2 !== 'string') {
                            _substr2 = '{' + _substr2 + '}';
                        }
                        if (name === expandedName) {
                            start = str.length;
                            length = _substr2.length;
                            str += _substr2;
                        } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {
                            str += _substr2;
                        } else {
                            str += '...';
                        }
                    }
                    str += '>';
                } else {
                    str = '{';
                    var _object = objectOrArray;
                    var _names = Object.keys(_object);
                    for(var _i3 = 0; _i3 < _names.length; _i3++){
                        if (_i3 > 0) {
                            str += ', ';
                        }
                        var _name = _names[_i3];
                        str += describeKeyForErrorMessage(_name) + ': ';
                        var _value3 = _object[_name];
                        var _substr3 = void 0;
                        if (typeof _value3 === 'object' && _value3 !== null) {
                            _substr3 = describeObjectForErrorMessage(_value3);
                        } else {
                            _substr3 = describeValueForErrorMessage(_value3);
                        }
                        if (_name === expandedName) {
                            start = str.length;
                            length = _substr3.length;
                            str += _substr3;
                        } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {
                            str += _substr3;
                        } else {
                            str += '...';
                        }
                    }
                    str += '}';
                }
            }
            if (expandedName === undefined) {
                return str;
            }
            if (start > -1 && length > 0) {
                var highlight = ' '.repeat(start) + '^'.repeat(length);
                return '\n  ' + str + '\n  ' + highlight;
            }
            return '\n  ' + str;
        }
        var ContextRegistry = ReactSharedInternals.ContextRegistry;
        function getOrCreateServerContext(globalName) {
            if (!ContextRegistry[globalName]) {
                ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
            }
            return ContextRegistry[globalName];
        }
        var stringify = JSON.stringify;
        var PENDING$1 = 0;
        var COMPLETED = 1;
        var ABORTED = 3;
        var ERRORED$1 = 4;
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;
        function defaultErrorHandler(error) {
            console['error'](error);
        }
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {
            if (ReactCurrentCache.current !== null && ReactCurrentCache.current !== DefaultCacheDispatcher) {
                throw new Error('Currently React only supports one RSC renderer at a time.');
            }
            prepareHostDispatcher();
            ReactCurrentCache.current = DefaultCacheDispatcher;
            var abortSet = new Set();
            var pingedTasks = [];
            var hints = createHints();
            var request = {
                status: OPEN,
                flushScheduled: false,
                fatalError: null,
                destination: null,
                bundlerConfig: bundlerConfig,
                cache: new Map(),
                nextChunkId: 0,
                pendingChunks: 0,
                hints: hints,
                abortableTasks: abortSet,
                pingedTasks: pingedTasks,
                completedImportChunks: [],
                completedHintChunks: [],
                completedJSONChunks: [],
                completedErrorChunks: [],
                writtenSymbols: new Map(),
                writtenClientReferences: new Map(),
                writtenServerReferences: new Map(),
                writtenProviders: new Map(),
                identifierPrefix: identifierPrefix || '',
                identifierCount: 1,
                onError: onError === undefined ? defaultErrorHandler : onError,
                toJSON: function(key, value) {
                    return resolveModelToJSON(request, this, key, value);
                }
            };
            request.pendingChunks++;
            var rootContext = createRootContext(context);
            var rootTask = createTask(request, model, rootContext, abortSet);
            pingedTasks.push(rootTask);
            return request;
        }
        var currentRequest = null;
        function resolveRequest() {
            if (currentRequest) return currentRequest;
            if (supportsRequestStorage) {
                var store = requestStorage.getStore();
                if (store) return store;
            }
            return null;
        }
        function createRootContext(reqContext) {
            return importServerContexts(reqContext);
        }
        var POP = {};
        function serializeThenable(request, thenable) {
            request.pendingChunks++;
            var newTask = createTask(request, null, getActiveContext(), request.abortableTasks);
            switch(thenable.status){
                case 'fulfilled':
                    {
                        newTask.model = thenable.value;
                        pingTask(request, newTask);
                        return newTask.id;
                    }
                case 'rejected':
                    {
                        var x = thenable.reason;
                        var digest = logRecoverableError(request, x);
                        {
                            var _getErrorMessageAndSt = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt.message, stack = _getErrorMessageAndSt.stack;
                            emitErrorChunkDev(request, newTask.id, digest, message, stack);
                        }
                        return newTask.id;
                    }
                default:
                    {
                        if (typeof thenable.status === 'string') {
                            break;
                        }
                        var pendingThenable = thenable;
                        pendingThenable.status = 'pending';
                        pendingThenable.then(function(fulfilledValue) {
                            if (thenable.status === 'pending') {
                                var fulfilledThenable = thenable;
                                fulfilledThenable.status = 'fulfilled';
                                fulfilledThenable.value = fulfilledValue;
                            }
                        }, function(error) {
                            if (thenable.status === 'pending') {
                                var rejectedThenable = thenable;
                                rejectedThenable.status = 'rejected';
                                rejectedThenable.reason = error;
                            }
                        });
                        break;
                    }
            }
            thenable.then(function(value) {
                newTask.model = value;
                pingTask(request, newTask);
            }, function(reason) {
                newTask.status = ERRORED$1;
                var digest = logRecoverableError(request, reason);
                {
                    var _getErrorMessageAndSt2 = getErrorMessageAndStackDev(reason), _message = _getErrorMessageAndSt2.message, _stack = _getErrorMessageAndSt2.stack;
                    emitErrorChunkDev(request, newTask.id, digest, _message, _stack);
                }
                if (request.destination !== null) {
                    flushCompletedChunks(request, request.destination);
                }
            });
            return newTask.id;
        }
        function emitHint(request, code, model) {
            emitHintChunk(request, code, model);
            enqueueFlush(request);
        }
        function getHints(request) {
            return request.hints;
        }
        function getCache(request) {
            return request.cache;
        }
        function readThenable(thenable) {
            if (thenable.status === 'fulfilled') {
                return thenable.value;
            } else if (thenable.status === 'rejected') {
                throw thenable.reason;
            }
            throw thenable;
        }
        function createLazyWrapperAroundWakeable(wakeable) {
            var thenable = wakeable;
            switch(thenable.status){
                case 'fulfilled':
                case 'rejected':
                    break;
                default:
                    {
                        if (typeof thenable.status === 'string') {
                            break;
                        }
                        var pendingThenable = thenable;
                        pendingThenable.status = 'pending';
                        pendingThenable.then(function(fulfilledValue) {
                            if (thenable.status === 'pending') {
                                var fulfilledThenable = thenable;
                                fulfilledThenable.status = 'fulfilled';
                                fulfilledThenable.value = fulfilledValue;
                            }
                        }, function(error) {
                            if (thenable.status === 'pending') {
                                var rejectedThenable = thenable;
                                rejectedThenable.status = 'rejected';
                                rejectedThenable.reason = error;
                            }
                        });
                        break;
                    }
            }
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: thenable,
                _init: readThenable
            };
            return lazyType;
        }
        function attemptResolveElement(request, type, key, ref, props, prevThenableState) {
            if (ref !== null && ref !== undefined) {
                throw new Error('Refs cannot be used in Server Components, nor passed to Client Components.');
            }
            {
                jsxPropsParents.set(props, type);
                if (typeof props.children === 'object' && props.children !== null) {
                    jsxChildrenParents.set(props.children, type);
                }
            }
            if (typeof type === 'function') {
                if (isClientReference(type)) {
                    return [
                        REACT_ELEMENT_TYPE,
                        type,
                        key,
                        props
                    ];
                }
                prepareToUseHooksForComponent(prevThenableState);
                var result = type(props);
                if (typeof result === 'object' && result !== null && typeof result.then === 'function') {
                    var thenable = result;
                    if (thenable.status === 'fulfilled') {
                        return thenable.value;
                    }
                    return createLazyWrapperAroundWakeable(result);
                }
                return result;
            } else if (typeof type === 'string') {
                return [
                    REACT_ELEMENT_TYPE,
                    type,
                    key,
                    props
                ];
            } else if (typeof type === 'symbol') {
                if (type === REACT_FRAGMENT_TYPE) {
                    return props.children;
                }
                return [
                    REACT_ELEMENT_TYPE,
                    type,
                    key,
                    props
                ];
            } else if (type != null && typeof type === 'object') {
                if (isClientReference(type)) {
                    return [
                        REACT_ELEMENT_TYPE,
                        type,
                        key,
                        props
                    ];
                }
                switch(type.$$typeof){
                    case REACT_LAZY_TYPE:
                        {
                            var payload = type._payload;
                            var init = type._init;
                            var wrappedType = init(payload);
                            return attemptResolveElement(request, wrappedType, key, ref, props, prevThenableState);
                        }
                    case REACT_FORWARD_REF_TYPE:
                        {
                            var render = type.render;
                            prepareToUseHooksForComponent(prevThenableState);
                            return render(props, undefined);
                        }
                    case REACT_MEMO_TYPE:
                        {
                            return attemptResolveElement(request, type.type, key, ref, props, prevThenableState);
                        }
                    case REACT_PROVIDER_TYPE:
                        {
                            pushProvider(type._context, props.value);
                            {
                                var extraKeys = Object.keys(props).filter(function(value) {
                                    if (value === 'children' || value === 'value') {
                                        return false;
                                    }
                                    return true;
                                });
                                if (extraKeys.length !== 0) {
                                    error('ServerContext can only have a value prop and children. Found: %s', JSON.stringify(extraKeys));
                                }
                            }
                            return [
                                REACT_ELEMENT_TYPE,
                                type,
                                key,
                                {
                                    value: props.value,
                                    children: props.children,
                                    __pop: POP
                                }
                            ];
                        }
                }
            }
            throw new Error("Unsupported Server Component type: " + describeValueForErrorMessage(type));
        }
        function pingTask(request, task) {
            var pingedTasks = request.pingedTasks;
            pingedTasks.push(task);
            if (pingedTasks.length === 1) {
                request.flushScheduled = request.destination !== null;
                scheduleWork(function() {
                    return performWork(request);
                });
            }
        }
        function createTask(request, model, context, abortSet) {
            var id = request.nextChunkId++;
            var task = {
                id: id,
                status: PENDING$1,
                model: model,
                context: context,
                ping: function() {
                    return pingTask(request, task);
                },
                thenableState: null
            };
            abortSet.add(task);
            return task;
        }
        function serializeByValueID(id) {
            return '$' + id.toString(16);
        }
        function serializeLazyID(id) {
            return '$L' + id.toString(16);
        }
        function serializePromiseID(id) {
            return '$@' + id.toString(16);
        }
        function serializeServerReferenceID(id) {
            return '$F' + id.toString(16);
        }
        function serializeSymbolReference(name) {
            return '$S' + name;
        }
        function serializeProviderReference(name) {
            return '$P' + name;
        }
        function serializeNumber(number) {
            if (Number.isFinite(number)) {
                if (number === 0 && 1 / number === -Infinity) {
                    return '$-0';
                } else {
                    return number;
                }
            } else {
                if (number === Infinity) {
                    return '$Infinity';
                } else if (number === -Infinity) {
                    return '$-Infinity';
                } else {
                    return '$NaN';
                }
            }
        }
        function serializeUndefined() {
            return '$undefined';
        }
        function serializeDateFromDateJSON(dateJSON) {
            return '$D' + dateJSON;
        }
        function serializeBigInt(n) {
            return '$n' + n.toString(10);
        }
        function serializeClientReference(request, parent, key, clientReference) {
            var clientReferenceKey = getClientReferenceKey(clientReference);
            var writtenClientReferences = request.writtenClientReferences;
            var existingId = writtenClientReferences.get(clientReferenceKey);
            if (existingId !== undefined) {
                if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
                    return serializeLazyID(existingId);
                }
                return serializeByValueID(existingId);
            }
            try {
                var clientReferenceMetadata = resolveClientReferenceMetadata(request.bundlerConfig, clientReference);
                request.pendingChunks++;
                var importId = request.nextChunkId++;
                emitImportChunk(request, importId, clientReferenceMetadata);
                writtenClientReferences.set(clientReferenceKey, importId);
                if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
                    return serializeLazyID(importId);
                }
                return serializeByValueID(importId);
            } catch (x) {
                request.pendingChunks++;
                var errorId = request.nextChunkId++;
                var digest = logRecoverableError(request, x);
                {
                    var _getErrorMessageAndSt3 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt3.message, stack = _getErrorMessageAndSt3.stack;
                    emitErrorChunkDev(request, errorId, digest, message, stack);
                }
                return serializeByValueID(errorId);
            }
        }
        function serializeServerReference(request, parent, key, serverReference) {
            var writtenServerReferences = request.writtenServerReferences;
            var existingId = writtenServerReferences.get(serverReference);
            if (existingId !== undefined) {
                return serializeServerReferenceID(existingId);
            }
            var bound = getServerReferenceBoundArguments(request.bundlerConfig, serverReference);
            var serverReferenceMetadata = {
                id: getServerReferenceId(request.bundlerConfig, serverReference),
                bound: bound ? Promise.resolve(bound) : null
            };
            request.pendingChunks++;
            var metadataId = request.nextChunkId++;
            var processedChunk = processModelChunk(request, metadataId, serverReferenceMetadata);
            request.completedJSONChunks.push(processedChunk);
            writtenServerReferences.set(serverReference, metadataId);
            return serializeServerReferenceID(metadataId);
        }
        function escapeStringValue(value) {
            if (value[0] === '$') {
                return '$' + value;
            } else {
                return value;
            }
        }
        var insideContextProps = null;
        var isInsideContextValue = false;
        function resolveModelToJSON(request, parent, key, value) {
            {
                var originalValue = parent[key];
                if (typeof originalValue === 'object' && originalValue !== value && !(originalValue instanceof Date)) {
                    if (objectName(originalValue) !== 'Object') {
                        var jsxParentType = jsxChildrenParents.get(parent);
                        if (typeof jsxParentType === 'string') {
                            error('%s objects cannot be rendered as text children. Try formatting it using toString().%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
                        } else {
                            error('Only plain objects can be passed to Client Components from Server Components. ' + '%s objects are not supported.%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
                        }
                    } else {
                        error('Only plain objects can be passed to Client Components from Server Components. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props.%s', describeObjectForErrorMessage(parent, key));
                    }
                }
            }
            switch(value){
                case REACT_ELEMENT_TYPE:
                    return '$';
            }
            {
                if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === '3') {
                    insideContextProps = value;
                } else if (insideContextProps === parent && key === 'value') {
                    isInsideContextValue = true;
                } else if (insideContextProps === parent && key === 'children') {
                    isInsideContextValue = false;
                }
            }
            while(typeof value === 'object' && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)){
                {
                    if (isInsideContextValue) {
                        error('React elements are not allowed in ServerContext');
                    }
                }
                try {
                    switch(value.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            {
                                var element = value;
                                value = attemptResolveElement(request, element.type, element.key, element.ref, element.props, null);
                                break;
                            }
                        case REACT_LAZY_TYPE:
                            {
                                var payload = value._payload;
                                var init = value._init;
                                value = init(payload);
                                break;
                            }
                    }
                } catch (thrownValue) {
                    var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                        request.pendingChunks++;
                        var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);
                        var ping = newTask.ping;
                        x.then(ping, ping);
                        newTask.thenableState = getThenableStateAfterSuspending();
                        return serializeLazyID(newTask.id);
                    } else {
                        request.pendingChunks++;
                        var errorId = request.nextChunkId++;
                        var digest = logRecoverableError(request, x);
                        {
                            var _getErrorMessageAndSt4 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt4.message, stack = _getErrorMessageAndSt4.stack;
                            emitErrorChunkDev(request, errorId, digest, message, stack);
                        }
                        return serializeLazyID(errorId);
                    }
                }
            }
            if (value === null) {
                return null;
            }
            if (typeof value === 'object') {
                if (isClientReference(value)) {
                    return serializeClientReference(request, parent, key, value);
                } else if (typeof value.then === 'function') {
                    var promiseId = serializeThenable(request, value);
                    return serializePromiseID(promiseId);
                } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
                    var providerKey = value._context._globalName;
                    var writtenProviders = request.writtenProviders;
                    var providerId = writtenProviders.get(key);
                    if (providerId === undefined) {
                        request.pendingChunks++;
                        providerId = request.nextChunkId++;
                        writtenProviders.set(providerKey, providerId);
                        emitProviderChunk(request, providerId, providerKey);
                    }
                    return serializeByValueID(providerId);
                } else if (value === POP) {
                    popProvider();
                    {
                        insideContextProps = null;
                        isInsideContextValue = false;
                    }
                    return undefined;
                }
                if (!isArray(value)) {
                    var iteratorFn = getIteratorFn(value);
                    if (iteratorFn) {
                        return Array.from(value);
                    }
                }
                {
                    if (value !== null && !isArray(value)) {
                        if (objectName(value) !== 'Object') {
                            error('Only plain objects can be passed to Client Components from Server Components. ' + '%s objects are not supported.%s', objectName(value), describeObjectForErrorMessage(parent, key));
                        } else if (!isSimpleObject(value)) {
                            error('Only plain objects can be passed to Client Components from Server Components. ' + 'Classes or other objects with methods are not supported.%s', describeObjectForErrorMessage(parent, key));
                        } else if (Object.getOwnPropertySymbols) {
                            var symbols = Object.getOwnPropertySymbols(value);
                            if (symbols.length > 0) {
                                error('Only plain objects can be passed to Client Components from Server Components. ' + 'Objects with symbol properties like %s are not supported.%s', symbols[0].description, describeObjectForErrorMessage(parent, key));
                            }
                        }
                    }
                }
                return value;
            }
            if (typeof value === 'string') {
                if (value[value.length - 1] === 'Z') {
                    var _originalValue = parent[key];
                    if (_originalValue instanceof Date) {
                        return serializeDateFromDateJSON(value);
                    }
                }
                return escapeStringValue(value);
            }
            if (typeof value === 'boolean') {
                return value;
            }
            if (typeof value === 'number') {
                return serializeNumber(value);
            }
            if (typeof value === 'undefined') {
                return serializeUndefined();
            }
            if (typeof value === 'function') {
                if (isClientReference(value)) {
                    return serializeClientReference(request, parent, key, value);
                }
                if (isServerReference(value)) {
                    return serializeServerReference(request, parent, key, value);
                }
                if (/^on[A-Z]/.test(key)) {
                    throw new Error('Event handlers cannot be passed to Client Component props.' + describeObjectForErrorMessage(parent, key) + '\nIf you need interactivity, consider converting part of this to a Client Component.');
                } else {
                    throw new Error('Functions cannot be passed directly to Client Components ' + 'unless you explicitly expose it by marking it with "use server".' + describeObjectForErrorMessage(parent, key));
                }
            }
            if (typeof value === 'symbol') {
                var writtenSymbols = request.writtenSymbols;
                var existingId = writtenSymbols.get(value);
                if (existingId !== undefined) {
                    return serializeByValueID(existingId);
                }
                var name = value.description;
                if (Symbol.for(name) !== value) {
                    throw new Error('Only global symbols received from Symbol.for(...) can be passed to Client Components. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols.") + describeObjectForErrorMessage(parent, key));
                }
                request.pendingChunks++;
                var symbolId = request.nextChunkId++;
                emitSymbolChunk(request, symbolId, name);
                writtenSymbols.set(value, symbolId);
                return serializeByValueID(symbolId);
            }
            if (typeof value === 'bigint') {
                return serializeBigInt(value);
            }
            throw new Error("Type " + typeof value + " is not supported in Client Component props." + describeObjectForErrorMessage(parent, key));
        }
        function logRecoverableError(request, error) {
            var onError = request.onError;
            var errorDigest = onError(error);
            if (errorDigest != null && typeof errorDigest !== 'string') {
                throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
            }
            return errorDigest || '';
        }
        function getErrorMessageAndStackDev(error) {
            {
                var message;
                var stack = '';
                try {
                    if (error instanceof Error) {
                        message = String(error.message);
                        stack = String(error.stack);
                    } else {
                        message = 'Error: ' + error;
                    }
                } catch (x) {
                    message = 'An error occurred but serializing the error message failed.';
                }
                return {
                    message: message,
                    stack: stack
                };
            }
        }
        function fatalError(request, error) {
            if (request.destination !== null) {
                request.status = CLOSED;
                closeWithError(request.destination, error);
            } else {
                request.status = CLOSING;
                request.fatalError = error;
            }
        }
        function emitErrorChunkProd(request, id, digest) {
            var processedChunk = processErrorChunkProd();
            request.completedErrorChunks.push(processedChunk);
        }
        function emitErrorChunkDev(request, id, digest, message, stack) {
            var processedChunk = processErrorChunkDev(request, id, digest, message, stack);
            request.completedErrorChunks.push(processedChunk);
        }
        function emitImportChunk(request, id, clientReferenceMetadata) {
            var processedChunk = processImportChunk(request, id, clientReferenceMetadata);
            request.completedImportChunks.push(processedChunk);
        }
        function emitHintChunk(request, code, model) {
            var processedChunk = processHintChunk(request, request.nextChunkId++, code, model);
            request.completedHintChunks.push(processedChunk);
        }
        function emitSymbolChunk(request, id, name) {
            var symbolReference = serializeSymbolReference(name);
            var processedChunk = processReferenceChunk(request, id, symbolReference);
            request.completedImportChunks.push(processedChunk);
        }
        function emitProviderChunk(request, id, contextName) {
            var contextReference = serializeProviderReference(contextName);
            var processedChunk = processReferenceChunk(request, id, contextReference);
            request.completedJSONChunks.push(processedChunk);
        }
        function retryTask(request, task) {
            if (task.status !== PENDING$1) {
                return;
            }
            switchContext(task.context);
            try {
                var value = task.model;
                if (typeof value === 'object' && value !== null && value.$$typeof === REACT_ELEMENT_TYPE) {
                    var element = value;
                    var prevThenableState = task.thenableState;
                    task.model = value;
                    value = attemptResolveElement(request, element.type, element.key, element.ref, element.props, prevThenableState);
                    task.thenableState = null;
                    while(typeof value === 'object' && value !== null && value.$$typeof === REACT_ELEMENT_TYPE){
                        var nextElement = value;
                        task.model = value;
                        value = attemptResolveElement(request, nextElement.type, nextElement.key, nextElement.ref, nextElement.props, null);
                    }
                }
                var processedChunk = processModelChunk(request, task.id, value);
                request.completedJSONChunks.push(processedChunk);
                request.abortableTasks.delete(task);
                task.status = COMPLETED;
            } catch (thrownValue) {
                var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                    var ping = task.ping;
                    x.then(ping, ping);
                    task.thenableState = getThenableStateAfterSuspending();
                    return;
                } else {
                    request.abortableTasks.delete(task);
                    task.status = ERRORED$1;
                    var digest = logRecoverableError(request, x);
                    {
                        var _getErrorMessageAndSt5 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt5.message, stack = _getErrorMessageAndSt5.stack;
                        emitErrorChunkDev(request, task.id, digest, message, stack);
                    }
                }
            }
        }
        function performWork(request) {
            var prevDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = HooksDispatcher;
            var prevRequest = currentRequest;
            currentRequest = request;
            prepareToUseHooksForRequest(request);
            try {
                var pingedTasks = request.pingedTasks;
                request.pingedTasks = [];
                for(var i = 0; i < pingedTasks.length; i++){
                    var task = pingedTasks[i];
                    retryTask(request, task);
                }
                if (request.destination !== null) {
                    flushCompletedChunks(request, request.destination);
                }
            } catch (error) {
                logRecoverableError(request, error);
                fatalError(request, error);
            } finally{
                ReactCurrentDispatcher.current = prevDispatcher;
                resetHooksForRequest();
                currentRequest = prevRequest;
            }
        }
        function abortTask(task, request, errorId) {
            task.status = ABORTED;
            var ref = serializeByValueID(errorId);
            var processedChunk = processReferenceChunk(request, task.id, ref);
            request.completedErrorChunks.push(processedChunk);
        }
        function flushCompletedChunks(request, destination) {
            beginWriting();
            try {
                var importsChunks = request.completedImportChunks;
                var i = 0;
                for(; i < importsChunks.length; i++){
                    request.pendingChunks--;
                    var chunk = importsChunks[i];
                    var keepWriting = writeChunkAndReturn(destination, chunk);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                importsChunks.splice(0, i);
                var hintChunks = request.completedHintChunks;
                i = 0;
                for(; i < hintChunks.length; i++){
                    var _chunk = hintChunks[i];
                    var _keepWriting = writeChunkAndReturn(destination, _chunk);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                hintChunks.splice(0, i);
                var jsonChunks = request.completedJSONChunks;
                i = 0;
                for(; i < jsonChunks.length; i++){
                    request.pendingChunks--;
                    var _chunk2 = jsonChunks[i];
                    var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                jsonChunks.splice(0, i);
                var errorChunks = request.completedErrorChunks;
                i = 0;
                for(; i < errorChunks.length; i++){
                    request.pendingChunks--;
                    var _chunk3 = errorChunks[i];
                    var _keepWriting3 = writeChunkAndReturn(destination, _chunk3);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                errorChunks.splice(0, i);
            } finally{
                request.flushScheduled = false;
                completeWriting(destination);
            }
            if (request.pendingChunks === 0) {
                close$1(destination);
            }
        }
        function startWork(request) {
            request.flushScheduled = request.destination !== null;
            if (supportsRequestStorage) {
                scheduleWork(function() {
                    return requestStorage.run(request, performWork, request);
                });
            } else {
                scheduleWork(function() {
                    return performWork(request);
                });
            }
        }
        function enqueueFlush(request) {
            if (request.flushScheduled === false && request.pingedTasks.length === 0 && request.destination !== null) {
                var destination = request.destination;
                request.flushScheduled = true;
                scheduleWork(function() {
                    return flushCompletedChunks(request, destination);
                });
            }
        }
        function startFlowing(request, destination) {
            if (request.status === CLOSING) {
                request.status = CLOSED;
                closeWithError(destination, request.fatalError);
                return;
            }
            if (request.status === CLOSED) {
                return;
            }
            if (request.destination !== null) {
                return;
            }
            request.destination = destination;
            try {
                flushCompletedChunks(request, destination);
            } catch (error) {
                logRecoverableError(request, error);
                fatalError(request, error);
            }
        }
        function abort(request, reason) {
            try {
                var abortableTasks = request.abortableTasks;
                if (abortableTasks.size > 0) {
                    var error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
                    var digest = logRecoverableError(request, error);
                    request.pendingChunks++;
                    var errorId = request.nextChunkId++;
                    if ("TURBOPACK compile-time truthy", 1) {
                        var _getErrorMessageAndSt6 = getErrorMessageAndStackDev(error), message = _getErrorMessageAndSt6.message, stack = _getErrorMessageAndSt6.stack;
                        emitErrorChunkDev(request, errorId, digest, message, stack);
                    }
                    abortableTasks.forEach(function(task) {
                        return abortTask(task, request, errorId);
                    });
                    abortableTasks.clear();
                }
                if (request.destination !== null) {
                    flushCompletedChunks(request, request.destination);
                }
            } catch (error) {
                logRecoverableError(request, error);
                fatalError(request, error);
            }
        }
        function importServerContexts(contexts) {
            if (contexts) {
                var prevContext = getActiveContext();
                switchContext(rootContextSnapshot);
                for(var i = 0; i < contexts.length; i++){
                    var _contexts$i = contexts[i], name = _contexts$i[0], value = _contexts$i[1];
                    var context = getOrCreateServerContext(name);
                    pushProvider(context, value);
                }
                var importedContext = getActiveContext();
                switchContext(prevContext);
                return importedContext;
            }
            return rootContextSnapshot;
        }
        function serializeRowHeader(tag, id) {
            return id.toString(16) + ':' + tag;
        }
        function processErrorChunkProd(request, id, digest) {
            {
                throw new Error('processErrorChunkProd should never be called while in development mode. Use processErrorChunkDev instead. This is a bug in React.');
            }
        }
        function processErrorChunkDev(request, id, digest, message, stack) {
            var errorInfo = {
                digest: digest,
                message: message,
                stack: stack
            };
            var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
            return stringToChunk(row);
        }
        function processModelChunk(request, id, model) {
            var json = stringify(model, request.toJSON);
            var row = id.toString(16) + ':' + json + '\n';
            return stringToChunk(row);
        }
        function processReferenceChunk(request, id, reference) {
            var json = stringify(reference);
            var row = id.toString(16) + ':' + json + '\n';
            return stringToChunk(row);
        }
        function processImportChunk(request, id, clientReferenceMetadata) {
            var json = stringify(clientReferenceMetadata);
            var row = serializeRowHeader('I', id) + json + '\n';
            return stringToChunk(row);
        }
        function processHintChunk(request, id, code, model) {
            var json = stringify(model);
            var row = serializeRowHeader('H' + code, id) + json + '\n';
            return stringToChunk(row);
        }
        function resolveServerReference(bundlerConfig, id) {
            var name = '';
            var resolvedModuleData = bundlerConfig[id];
            if (resolvedModuleData) {
                name = resolvedModuleData.name;
            } else {
                var idx = id.lastIndexOf('#');
                if (idx !== -1) {
                    name = id.slice(idx + 1);
                    resolvedModuleData = bundlerConfig[id.slice(0, idx)];
                }
                if (!resolvedModuleData) {
                    throw new Error('Could not find the module "' + id + '" in the React Server Manifest. ' + 'This is probably a bug in the React Server Components bundler.');
                }
            }
            return {
                id: resolvedModuleData.id,
                chunks: resolvedModuleData.chunks,
                name: name,
                async: false
            };
        }
        var chunkCache = new Map();
        var asyncModuleCache = new Map();
        function ignoreReject() {}
        function preloadModule(metadata) {
            var chunks = metadata.chunks;
            var promises = [];
            for(var i = 0; i < chunks.length; i++){
                var chunkId = chunks[i];
                var entry = chunkCache.get(chunkId);
                if (entry === undefined) {
                    var thenable = globalThis.__next_chunk_load__(chunkId);
                    promises.push(thenable);
                    var resolve = chunkCache.set.bind(chunkCache, chunkId, null);
                    thenable.then(resolve, ignoreReject);
                    chunkCache.set(chunkId, thenable);
                } else if (entry !== null) {
                    promises.push(entry);
                }
            }
            if (metadata.async) {
                var existingPromise = asyncModuleCache.get(metadata.id);
                if (existingPromise) {
                    if (existingPromise.status === 'fulfilled') {
                        return null;
                    }
                    return existingPromise;
                } else {
                    var modulePromise = Promise.all(promises).then(function() {
                        return globalThis.__next_require__(metadata.id);
                    });
                    modulePromise.then(function(value) {
                        var fulfilledThenable = modulePromise;
                        fulfilledThenable.status = 'fulfilled';
                        fulfilledThenable.value = value;
                    }, function(reason) {
                        var rejectedThenable = modulePromise;
                        rejectedThenable.status = 'rejected';
                        rejectedThenable.reason = reason;
                    });
                    asyncModuleCache.set(metadata.id, modulePromise);
                    return modulePromise;
                }
            } else if (promises.length > 0) {
                return Promise.all(promises);
            } else {
                return null;
            }
        }
        function requireModule(metadata) {
            var moduleExports;
            if (metadata.async) {
                var promise = asyncModuleCache.get(metadata.id);
                if (promise.status === 'fulfilled') {
                    moduleExports = promise.value;
                } else {
                    throw promise.reason;
                }
            } else {
                moduleExports = globalThis.__next_require__(metadata.id);
            }
            if (metadata.name === '*') {
                return moduleExports;
            }
            if (metadata.name === '') {
                return moduleExports.__esModule ? moduleExports.default : moduleExports;
            }
            return moduleExports[metadata.name];
        }
        var PENDING = 'pending';
        var BLOCKED = 'blocked';
        var RESOLVED_MODEL = 'resolved_model';
        var INITIALIZED = 'fulfilled';
        var ERRORED = 'rejected';
        function Chunk(status, value, reason, response) {
            this.status = status;
            this.value = value;
            this.reason = reason;
            this._response = response;
        }
        Chunk.prototype = Object.create(Promise.prototype);
        Chunk.prototype.then = function(resolve, reject) {
            var chunk = this;
            switch(chunk.status){
                case RESOLVED_MODEL:
                    initializeModelChunk(chunk);
                    break;
            }
            switch(chunk.status){
                case INITIALIZED:
                    resolve(chunk.value);
                    break;
                case PENDING:
                case BLOCKED:
                    if (resolve) {
                        if (chunk.value === null) {
                            chunk.value = [];
                        }
                        chunk.value.push(resolve);
                    }
                    if (reject) {
                        if (chunk.reason === null) {
                            chunk.reason = [];
                        }
                        chunk.reason.push(reject);
                    }
                    break;
                default:
                    reject(chunk.reason);
                    break;
            }
        };
        function getRoot(response) {
            var chunk = getChunk(response, 0);
            return chunk;
        }
        function createPendingChunk(response) {
            return new Chunk(PENDING, null, null, response);
        }
        function wakeChunk(listeners, value) {
            for(var i = 0; i < listeners.length; i++){
                var listener = listeners[i];
                listener(value);
            }
        }
        function triggerErrorOnChunk(chunk, error) {
            if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
                return;
            }
            var listeners = chunk.reason;
            var erroredChunk = chunk;
            erroredChunk.status = ERRORED;
            erroredChunk.reason = error;
            if (listeners !== null) {
                wakeChunk(listeners, error);
            }
        }
        function createResolvedModelChunk(response, value) {
            return new Chunk(RESOLVED_MODEL, value, null, response);
        }
        function bindArgs$1(fn, args) {
            return fn.bind.apply(fn, [
                null
            ].concat(args));
        }
        function loadServerReference$1(response, id, bound, parentChunk, parentObject, key) {
            var serverReference = resolveServerReference(response._bundlerConfig, id);
            var preloadPromise = preloadModule(serverReference);
            var promise;
            if (bound) {
                promise = Promise.all([
                    bound,
                    preloadPromise
                ]).then(function(_ref) {
                    var args = _ref[0];
                    return bindArgs$1(requireModule(serverReference), args);
                });
            } else {
                if (preloadPromise) {
                    promise = Promise.resolve(preloadPromise).then(function() {
                        return requireModule(serverReference);
                    });
                } else {
                    return requireModule(serverReference);
                }
            }
            promise.then(createModelResolver(parentChunk, parentObject, key), createModelReject(parentChunk));
            return null;
        }
        var initializingChunk = null;
        var initializingChunkBlockedModel = null;
        function initializeModelChunk(chunk) {
            var prevChunk = initializingChunk;
            var prevBlocked = initializingChunkBlockedModel;
            initializingChunk = chunk;
            initializingChunkBlockedModel = null;
            try {
                var value = JSON.parse(chunk.value, chunk._response._fromJSON);
                if (initializingChunkBlockedModel !== null && initializingChunkBlockedModel.deps > 0) {
                    initializingChunkBlockedModel.value = value;
                    var blockedChunk = chunk;
                    blockedChunk.status = BLOCKED;
                    blockedChunk.value = null;
                    blockedChunk.reason = null;
                } else {
                    var initializedChunk = chunk;
                    initializedChunk.status = INITIALIZED;
                    initializedChunk.value = value;
                }
            } catch (error) {
                var erroredChunk = chunk;
                erroredChunk.status = ERRORED;
                erroredChunk.reason = error;
            } finally{
                initializingChunk = prevChunk;
                initializingChunkBlockedModel = prevBlocked;
            }
        }
        function reportGlobalError(response, error) {
            response._chunks.forEach(function(chunk) {
                if (chunk.status === PENDING) {
                    triggerErrorOnChunk(chunk, error);
                }
            });
        }
        function getChunk(response, id) {
            var chunks = response._chunks;
            var chunk = chunks.get(id);
            if (!chunk) {
                var prefix = response._prefix;
                var key = prefix + id;
                var backingEntry = response._formData.get(key);
                if (backingEntry != null) {
                    chunk = createResolvedModelChunk(response, backingEntry);
                } else {
                    chunk = createPendingChunk(response);
                }
                chunks.set(id, chunk);
            }
            return chunk;
        }
        function createModelResolver(chunk, parentObject, key) {
            var blocked;
            if (initializingChunkBlockedModel) {
                blocked = initializingChunkBlockedModel;
                blocked.deps++;
            } else {
                blocked = initializingChunkBlockedModel = {
                    deps: 1,
                    value: null
                };
            }
            return function(value) {
                parentObject[key] = value;
                blocked.deps--;
                if (blocked.deps === 0) {
                    if (chunk.status !== BLOCKED) {
                        return;
                    }
                    var resolveListeners = chunk.value;
                    var initializedChunk = chunk;
                    initializedChunk.status = INITIALIZED;
                    initializedChunk.value = blocked.value;
                    if (resolveListeners !== null) {
                        wakeChunk(resolveListeners, blocked.value);
                    }
                }
            };
        }
        function createModelReject(chunk) {
            return function(error) {
                return triggerErrorOnChunk(chunk, error);
            };
        }
        function parseModelString(response, parentObject, key, value) {
            if (value[0] === '$') {
                switch(value[1]){
                    case '$':
                        {
                            return value.slice(1);
                        }
                    case '@':
                        {
                            var id = parseInt(value.slice(2), 16);
                            var chunk = getChunk(response, id);
                            return chunk;
                        }
                    case 'S':
                        {
                            return Symbol.for(value.slice(2));
                        }
                    case 'F':
                        {
                            var _id = parseInt(value.slice(2), 16);
                            var _chunk = getChunk(response, _id);
                            if (_chunk.status === RESOLVED_MODEL) {
                                initializeModelChunk(_chunk);
                            }
                            if (_chunk.status !== INITIALIZED) {
                                throw _chunk.reason;
                            }
                            var metaData = _chunk.value;
                            return loadServerReference$1(response, metaData.id, metaData.bound, initializingChunk, parentObject, key);
                        }
                    case 'K':
                        {
                            var stringId = value.slice(2);
                            var formPrefix = response._prefix + stringId + '_';
                            var data = new FormData();
                            var backingFormData = response._formData;
                            backingFormData.forEach(function(entry, entryKey) {
                                if (entryKey.startsWith(formPrefix)) {
                                    data.append(entryKey.slice(formPrefix.length), entry);
                                }
                            });
                            return data;
                        }
                    case 'I':
                        {
                            return Infinity;
                        }
                    case '-':
                        {
                            if (value === '$-0') {
                                return -0;
                            } else {
                                return -Infinity;
                            }
                        }
                    case 'N':
                        {
                            return NaN;
                        }
                    case 'u':
                        {
                            return undefined;
                        }
                    case 'D':
                        {
                            return new Date(Date.parse(value.slice(2)));
                        }
                    case 'n':
                        {
                            return BigInt(value.slice(2));
                        }
                    default:
                        {
                            var _id2 = parseInt(value.slice(1), 16);
                            var _chunk2 = getChunk(response, _id2);
                            switch(_chunk2.status){
                                case RESOLVED_MODEL:
                                    initializeModelChunk(_chunk2);
                                    break;
                            }
                            switch(_chunk2.status){
                                case INITIALIZED:
                                    return _chunk2.value;
                                case PENDING:
                                case BLOCKED:
                                    var parentChunk = initializingChunk;
                                    _chunk2.then(createModelResolver(parentChunk, parentObject, key), createModelReject(parentChunk));
                                    return null;
                                default:
                                    throw _chunk2.reason;
                            }
                        }
                }
            }
            return value;
        }
        function createResponse(bundlerConfig, formFieldPrefix) {
            var backingFormData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new FormData();
            var chunks = new Map();
            var response = {
                _bundlerConfig: bundlerConfig,
                _prefix: formFieldPrefix,
                _formData: backingFormData,
                _chunks: chunks,
                _fromJSON: function(key, value) {
                    if (typeof value === 'string') {
                        return parseModelString(response, this, key, value);
                    }
                    return value;
                }
            };
            return response;
        }
        function close(response) {
            reportGlobalError(response, new Error('Connection closed.'));
        }
        function bindArgs(fn, args) {
            return fn.bind.apply(fn, [
                null
            ].concat(args));
        }
        function loadServerReference(bundlerConfig, id, bound) {
            var serverReference = resolveServerReference(bundlerConfig, id);
            var preloadPromise = preloadModule(serverReference);
            if (bound) {
                return Promise.all([
                    bound,
                    preloadPromise
                ]).then(function(_ref) {
                    var args = _ref[0];
                    return bindArgs(requireModule(serverReference), args);
                });
            } else if (preloadPromise) {
                return Promise.resolve(preloadPromise).then(function() {
                    return requireModule(serverReference);
                });
            } else {
                return Promise.resolve(requireModule(serverReference));
            }
        }
        function decodeAction(body, serverManifest) {
            var formData = new FormData();
            var action = null;
            body.forEach(function(value, key) {
                if (!key.startsWith('$ACTION_')) {
                    formData.append(key, value);
                    return;
                }
                if (key.startsWith('$ACTION_REF_')) {
                    var formFieldPrefix = '$ACTION_' + key.slice(12) + ':';
                    var actionResponse = createResponse(serverManifest, formFieldPrefix, body);
                    close(actionResponse);
                    var refPromise = getRoot(actionResponse);
                    refPromise.then(function() {});
                    if (refPromise.status !== 'fulfilled') {
                        throw refPromise.reason;
                    }
                    var metaData = refPromise.value;
                    action = loadServerReference(serverManifest, metaData.id, metaData.bound);
                    return;
                }
                if (key.startsWith('$ACTION_ID_')) {
                    var id = key.slice(11);
                    action = loadServerReference(serverManifest, id, null);
                    return;
                }
            });
            if (action === null) {
                return null;
            }
            return action.then(function(fn) {
                return fn.bind(null, formData);
            });
        }
        function renderToReadableStream(model, webpackMap, options) {
            var request = createRequest(model, webpackMap, options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);
            if (options && options.signal) {
                var signal = options.signal;
                if (signal.aborted) {
                    abort(request, signal.reason);
                } else {
                    var listener = function() {
                        abort(request, signal.reason);
                        signal.removeEventListener('abort', listener);
                    };
                    signal.addEventListener('abort', listener);
                }
            }
            var stream = new ReadableStream({
                type: 'bytes',
                start: function(controller) {
                    startWork(request);
                },
                pull: function(controller) {
                    startFlowing(request, controller);
                },
                cancel: function(reason) {}
            }, {
                highWaterMark: 0
            });
            return stream;
        }
        function decodeReply(body, webpackMap) {
            if (typeof body === 'string') {
                var form = new FormData();
                form.append('0', body);
                body = form;
            }
            var response = createResponse(webpackMap, '', body);
            close(response);
            return getRoot(response);
        }
        exports.decodeAction = decodeAction;
        exports.decodeReply = decodeReply;
        exports.renderToReadableStream = renderToReadableStream;
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
var _global_process, _global_process1;
module.exports = ((_global_process = global.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = global.process) == null ? void 0 : _global_process1.env) === "object" ? global.process : __turbopack_require__("[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript, rsc)");

}.call(this) }),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createProxy", {
    enumerable: true,
    get: function() {
        return createProxy;
    }
});
const CLIENT_REFERENCE = Symbol.for("react.client.reference");
const PROMISE_PROTOTYPE = Promise.prototype;
const deepProxyHandlers = {
    get: function(target, name, _receiver) {
        switch(name){
            case "$$typeof":
                return target.$$typeof;
            case "$$id":
                return target.$$id;
            case "$$async":
                return target.$$async;
            case "name":
                return target.name;
            case "displayName":
                return undefined;
            case "defaultProps":
                return undefined;
            case "toJSON":
                return undefined;
            case Symbol.toPrimitive.toString():
                return Object.prototype[Symbol.toPrimitive];
            case "Provider":
                throw new Error(`Cannot render a Client Context Provider on the Server. ` + `Instead, you can export a Client Component wrapper ` + `that itself renders a Client Context Provider.`);
            default:
                break;
        }
        const expression = String(target.name) + "." + String(name);
        throw new Error(`Cannot access ${expression} on the server. ` + "You cannot dot into a client module from a server component. " + "You can only pass the imported name through.");
    },
    set: function() {
        throw new Error("Cannot assign to a client module from a server module.");
    }
};
const proxyHandlers = {
    get: function(target, name, _receiver) {
        switch(name){
            case "$$typeof":
                return target.$$typeof;
            case "$$id":
                return target.$$id;
            case "$$async":
                return target.$$async;
            case "name":
                return target.name;
            case "defaultProps":
                return undefined;
            case "toJSON":
                return undefined;
            case Symbol.toPrimitive.toString():
                return Object.prototype[Symbol.toPrimitive];
            case "__esModule":
                const moduleId = target.$$id;
                target.default = Object.defineProperties(function() {
                    throw new Error(`Attempted to call the default export of ${moduleId} from the server ` + `but it's on the client. It's not possible to invoke a client function from ` + `the server, it can only be rendered as a Component or passed to props of a ` + `Client Component.`);
                }, {
                    $$typeof: {
                        value: CLIENT_REFERENCE
                    },
                    $$id: {
                        value: target.$$id + "#"
                    },
                    $$async: {
                        value: target.$$async
                    }
                });
                return true;
            case "then":
                if (target.then) {
                    return target.then;
                }
                if (!target.$$async) {
                    const clientReference = Object.defineProperties({}, {
                        $$typeof: {
                            value: CLIENT_REFERENCE
                        },
                        $$id: {
                            value: target.$$id
                        },
                        $$async: {
                            value: true
                        }
                    });
                    const proxy = new Proxy(clientReference, proxyHandlers);
                    target.status = "fulfilled";
                    target.value = proxy;
                    const then = target.then = Object.defineProperties(function then(resolve, _reject) {
                        return Promise.resolve(resolve(proxy));
                    }, {
                        $$typeof: {
                            value: CLIENT_REFERENCE
                        },
                        $$id: {
                            value: target.$$id
                        },
                        $$async: {
                            value: false
                        }
                    });
                    return then;
                } else {
                    return undefined;
                }
            default:
                break;
        }
        let cachedReference = target[name];
        if (!cachedReference) {
            const reference = Object.defineProperties(function() {
                throw new Error(`Attempted to call ${String(name)}() from the server but ${String(name)} is on the client. ` + `It's not possible to invoke a client function from the server, it can ` + `only be rendered as a Component or passed to props of a Client Component.`);
            }, {
                $$typeof: {
                    value: CLIENT_REFERENCE
                },
                $$id: {
                    value: target.$$id + "#" + name
                },
                $$async: {
                    value: target.$$async
                }
            });
            cachedReference = target[name] = new Proxy(reference, deepProxyHandlers);
        }
        return cachedReference;
    },
    getPrototypeOf (_target) {
        return PROMISE_PROTOTYPE;
    },
    set: function() {
        throw new Error("Cannot assign to a client module from a server module.");
    }
};
function createProxy(moduleId) {
    const clientReference = Object.defineProperties({}, {
        $$typeof: {
            value: CLIENT_REFERENCE
        },
        $$id: {
            value: moduleId
        },
        $$async: {
            value: false
        }
    });
    return new Proxy(clientReference, proxyHandlers);
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/rsc/preloads.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    preloadStyle: null,
    preloadFont: null,
    preconnect: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    preloadStyle: function() {
        return preloadStyle;
    },
    preloadFont: function() {
        return preloadFont;
    },
    preconnect: function() {
        return preconnect;
    }
});
const _reactdom = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, rsc)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const stylePreloadOptions = {
    as: "style"
};
function preloadStyle(href) {
    _reactdom.default.preload(href, stylePreloadOptions);
}
function preloadFont(href, type) {
    _reactdom.default.preload(href, {
        as: "font",
        type
    });
}
function preconnect(href, crossOrigin) {
    if (typeof crossOrigin === "string") {
        _reactdom.default.preconnect(href, {
            crossOrigin
        });
    } else {
        _reactdom.default.preconnect(href);
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/entry-base.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname, x: __turbopack_external_require__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppRouter: null,
    LayoutRouter: null,
    RenderFromTemplateContext: null,
    staticGenerationAsyncStorage: null,
    requestAsyncStorage: null,
    actionAsyncStorage: null,
    staticGenerationBailout: null,
    createSearchParamsBailoutProxy: null,
    serverHooks: null,
    renderToReadableStream: null,
    decodeReply: null,
    decodeAction: null,
    preloadStyle: null,
    preloadFont: null,
    preconnect: null,
    StaticGenerationSearchParamsBailoutProvider: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppRouter: function() {
        return AppRouter;
    },
    LayoutRouter: function() {
        return LayoutRouter;
    },
    RenderFromTemplateContext: function() {
        return RenderFromTemplateContext;
    },
    staticGenerationAsyncStorage: function() {
        return staticGenerationAsyncStorage;
    },
    requestAsyncStorage: function() {
        return requestAsyncStorage;
    },
    actionAsyncStorage: function() {
        return actionAsyncStorage;
    },
    staticGenerationBailout: function() {
        return staticGenerationBailout;
    },
    createSearchParamsBailoutProxy: function() {
        return createSearchParamsBailoutProxy;
    },
    serverHooks: function() {
        return serverHooks;
    },
    renderToReadableStream: function() {
        return renderToReadableStream;
    },
    decodeReply: function() {
        return decodeReply;
    },
    decodeAction: function() {
        return decodeAction;
    },
    preloadStyle: function() {
        return preloadStyle;
    },
    preloadFont: function() {
        return preloadFont;
    },
    preconnect: function() {
        return preconnect;
    },
    StaticGenerationSearchParamsBailoutProvider: function() {
        return StaticGenerationSearchParamsBailoutProvider;
    }
});
const { default: AppRouter } = __turbopack_require__("[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, rsc)");
const { default: LayoutRouter } = __turbopack_require__("[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, rsc)");
const { default: RenderFromTemplateContext } = __turbopack_require__("[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, rsc)");
const { staticGenerationAsyncStorage } = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-async-storage.js (ecmascript, rsc)");
const { requestAsyncStorage } = __turbopack_require__("[project]/node_modules/next/dist/client/components/request-async-storage.js (ecmascript, rsc)");
const { actionAsyncStorage } = __turbopack_require__("[project]/node_modules/next/dist/client/components/action-async-storage.js (ecmascript, rsc)");
const { staticGenerationBailout } = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-bailout.js (ecmascript, rsc)");
const { default: StaticGenerationSearchParamsBailoutProvider } = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, rsc)");
const { createSearchParamsBailoutProxy } = __turbopack_require__("[project]/node_modules/next/dist/client/components/searchparams-bailout-proxy.js (ecmascript, rsc)");
const serverHooks = __turbopack_require__("[project]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, rsc)");
const { renderToReadableStream, decodeReply, decodeAction } = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js (ecmascript, rsc)");
const { preloadStyle, preloadFont, preconnect } = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/rsc/preloads.js (ecmascript, rsc)");

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/entry-base.js (ecmascript, client chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_cjs__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => __turbopack_import__("[project]/node_modules/next/dist/server/app-render/entry-base.js (ecmascript, rsc)"),
    chunks: () => chunks,
});
const chunks = [];

})()),
}]);

//# sourceMappingURL=_077f99._.js.map