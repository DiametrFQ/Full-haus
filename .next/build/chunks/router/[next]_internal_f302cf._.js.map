{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/headers.ts"],"sourcesContent":["import { ServerInfo } from './server'\r\n\r\nexport type Headers = Record<string, string | string[]>\r\n/**\r\n * Converts an array of raw header entries to a map of header names to values.\r\n */\r\nexport function headersFromEntries(entries: Array<[string, string]>): Headers {\r\n  const headers: Record<string, string | string[]> = Object.create(null)\r\n  for (const [key, value] of entries) {\r\n    if (key in headers) {\r\n      const prevValue = headers[key]\r\n      if (typeof prevValue === 'string') {\r\n        headers[key] = [prevValue, value]\r\n      } else {\r\n        prevValue.push(value)\r\n      }\r\n    } else {\r\n      headers[key] = value\r\n    }\r\n  }\r\n  return headers\r\n}\r\n\r\n/**\r\n * Transforms an array of elements into an array of pairs of elements.\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * toPairs([\"a\", \"b\", \"c\", \"d\"]) // => [[\"a\", \"b\"], [\"c\", \"d\"]]\r\n * ```\r\n */\r\nexport function toPairs<T>(arr: T[]): Array<[T, T]> {\r\n  if (arr.length % 2 !== 0) {\r\n    throw new Error('toPairs: expected an even number of elements')\r\n  }\r\n\r\n  const pairs: Array<[T, T]> = []\r\n  for (let i = 0; i < arr.length; i += 2) {\r\n    pairs.push([arr[i], arr[i + 1]])\r\n  }\r\n\r\n  return pairs\r\n}\r\n\r\n/**\r\n * These headers are provided by default to match the http-proxy behavior\r\n * https://github.com/http-party/node-http-proxy/blob/9b96cd72/lib/http-proxy/passes/web-incoming.js#L58-L86\r\n */\r\nexport function initProxiedHeaders(\r\n  headers: Headers,\r\n  proxiedFor: ServerInfo | null | undefined\r\n): Headers {\r\n  const hostname = proxiedFor?.hostname || 'localhost'\r\n  const port = String(proxiedFor?.port || 3000)\r\n  headers['x-forwarded-for'] = proxiedFor?.ip || '::1'\r\n  headers['x-forwarded-host'] = `${hostname}:${port}`\r\n  headers['x-forwarded-port'] = port\r\n  headers['x-forwarded-proto'] = proxiedFor?.protocol || 'http'\r\n  return headers\r\n}\r\n"],"names":[],"mappings":";;;;;AAMO,SAAS,mBAAmB,OAAgC;IACjE,MAAM,UAA6C,OAAO,MAAM,CAAC;IACjE,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,QAAS;QAClC,IAAI,OAAO,SAAS;YAClB,MAAM,YAAY,OAAO,CAAC,IAAI;YAC9B,IAAI,OAAO,cAAc,UAAU;gBACjC,OAAO,CAAC,IAAI,GAAG;oBAAC;oBAAW;iBAAM;YACnC,OAAO;gBACL,UAAU,IAAI,CAAC;YACjB;QACF,OAAO;YACL,OAAO,CAAC,IAAI,GAAG;QACjB;IACF;IACA,OAAO;AACT;AAWO,SAAS,QAAW,GAAQ;IACjC,IAAI,IAAI,MAAM,GAAG,MAAM,GAAG;QACxB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,QAAuB,EAAE;IAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;QACtC,MAAM,IAAI,CAAC;YAAC,GAAG,CAAC,EAAE;YAAE,GAAG,CAAC,IAAI,EAAE;SAAC;IACjC;IAEA,OAAO;AACT;AAMO,SAAS,mBACd,OAAgB,EAChB,UAAyC;IAEzC,MAAM,WAAW,YAAY,YAAY;IACzC,MAAM,OAAO,OAAO,YAAY,QAAQ;IACxC,OAAO,CAAC,kBAAkB,GAAG,YAAY,MAAM;IAC/C,OAAO,CAAC,mBAAmB,GAAG,CAAC,EAAE,SAAS,CAAC,EAAE,KAAK,CAAC;IACnD,OAAO,CAAC,mBAAmB,GAAG;IAC9B,OAAO,CAAC,oBAAoB,GAAG,YAAY,YAAY;IACvD,OAAO;AACT"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/server.ts"],"sourcesContent":["import type { ClientRequest, IncomingMessage, Server } from 'node:http'\r\nimport type { AddressInfo } from 'node:net'\r\nimport http, { ServerResponse } from 'node:http'\r\nimport { headersFromEntries, initProxiedHeaders } from './headers'\r\n\r\nexport type ServerInfo = Partial<{\r\n  hostname: string\r\n  port: number\r\n  ip: string\r\n  protocol: string\r\n}>\r\n\r\n/**\r\n * Creates a server that listens a random port.\r\n */\r\nexport function createServer(): Promise<Server> {\r\n  return new Promise((resolve) => {\r\n    const server = http.createServer()\r\n    server.listen(0, () => {\r\n      resolve(server)\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Creates a request to a server, and returns the (req, res) pairs from both\r\n * the client's and server's perspective.\r\n */\r\nexport function makeRequest(\r\n  server: Server,\r\n  method: string,\r\n  path: string,\r\n  rawQuery?: string,\r\n  rawHeaders?: [string, string][],\r\n  proxiedFor?: ServerInfo\r\n): Promise<{\r\n  clientRequest: ClientRequest\r\n  clientResponsePromise: Promise<IncomingMessage>\r\n  serverRequest: IncomingMessage\r\n  serverResponse: ServerResponse<IncomingMessage>\r\n}> {\r\n  return new Promise((resolve, reject) => {\r\n    let clientResponseResolve: (value: IncomingMessage) => void\r\n    let clientResponseReject: (error: Error) => void\r\n    const clientResponsePromise = new Promise<IncomingMessage>(\r\n      (resolve, reject) => {\r\n        clientResponseResolve = resolve\r\n        clientResponseReject = reject\r\n      }\r\n    )\r\n\r\n    const errorListener = (err: Error) => {\r\n      server.removeListener('request', requestListener)\r\n      reject(err)\r\n    }\r\n\r\n    const requestListener = (\r\n      req: IncomingMessage,\r\n      res: ServerResponse<IncomingMessage>\r\n    ) => {\r\n      server.removeListener('error', errorListener)\r\n      resolve({\r\n        clientRequest,\r\n        clientResponsePromise,\r\n        serverRequest: req,\r\n        serverResponse: res,\r\n      })\r\n    }\r\n\r\n    server.once('request', requestListener)\r\n    server.once('error', errorListener)\r\n\r\n    const address = server.address() as AddressInfo\r\n\r\n    const headers = headersFromEntries(rawHeaders ?? [])\r\n    initProxiedHeaders(headers, proxiedFor)\r\n\r\n    const clientRequest = http.request({\r\n      host: 'localhost',\r\n      port: address.port,\r\n      method,\r\n      path: rawQuery?.length ? `${path}?${rawQuery}` : path,\r\n      headers,\r\n    })\r\n\r\n    // Otherwise Node.js waits for the first chunk of data to be written before sending the request.\r\n    clientRequest.flushHeaders()\r\n\r\n    const clientResponseErrorListener = (err: Error) => {\r\n      clientRequest.removeListener('response', responseListener)\r\n      clientResponseReject(err)\r\n    }\r\n\r\n    const responseListener = (res: IncomingMessage) => {\r\n      clientRequest.removeListener('error', clientResponseErrorListener)\r\n      clientResponseResolve(res)\r\n    }\r\n\r\n    clientRequest.once('response', responseListener)\r\n    clientRequest.once('error', clientResponseErrorListener)\r\n  })\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;AAeO,SAAS;IACd,OAAO,IAAI,QAAQ,CAAC;QAClB,MAAM,SAAS,iDAAK,YAAY;QAChC,OAAO,MAAM,CAAC,GAAG;YACf,QAAQ;QACV;IACF;AACF;AAMO,SAAS,YACd,MAAc,EACd,MAAc,EACd,IAAY,EACZ,QAAiB,EACjB,UAA+B,EAC/B,UAAuB;IAOvB,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,IAAI;QACJ,IAAI;QACJ,MAAM,wBAAwB,IAAI,QAChC,CAAC,SAAS;YACR,wBAAwB;YACxB,uBAAuB;QACzB;QAGF,MAAM,gBAAgB,CAAC;YACrB,OAAO,cAAc,CAAC,WAAW;YACjC,OAAO;QACT;QAEA,MAAM,kBAAkB,CACtB,KACA;YAEA,OAAO,cAAc,CAAC,SAAS;YAC/B,QAAQ;gBACN;gBACA;gBACA,eAAe;gBACf,gBAAgB;YAClB;QACF;QAEA,OAAO,IAAI,CAAC,WAAW;QACvB,OAAO,IAAI,CAAC,SAAS;QAErB,MAAM,UAAU,OAAO,OAAO;QAE9B,MAAM,UAAU,mHAAmB,cAAc,EAAE;QACnD,mHAAmB,SAAS;QAE5B,MAAM,gBAAgB,iDAAK,OAAO,CAAC;YACjC,MAAM;YACN,MAAM,QAAQ,IAAI;YAClB;YACA,MAAM,UAAU,SAAS,CAAC,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC,GAAG;YACjD;QACF;QAGA,cAAc,YAAY;QAE1B,MAAM,8BAA8B,CAAC;YACnC,cAAc,cAAc,CAAC,YAAY;YACzC,qBAAqB;QACvB;QAEA,MAAM,mBAAmB,CAAC;YACxB,cAAc,cAAc,CAAC,SAAS;YACtC,sBAAsB;QACxB;QAEA,cAAc,IAAI,CAAC,YAAY;QAC/B,cAAc,IAAI,CAAC,SAAS;IAC9B;AACF"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}