{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/entry/router.ts"],"sourcesContent":["import type { Ipc, StructuredError } from '@vercel/turbopack-node/ipc/index'\r\nimport type { IncomingMessage } from 'node:http'\r\nimport { Buffer } from 'node:buffer'\r\nimport { createServer, makeRequest, type ServerInfo } from '../internal/server'\r\nimport { toPairs } from '../internal/headers'\r\nimport { makeResolver } from 'next/dist/server/lib/route-resolver'\r\nimport loadConfig from 'next/dist/server/config'\r\nimport { PHASE_DEVELOPMENT_SERVER } from 'next/dist/shared/lib/constants'\r\n\r\nimport 'next/dist/server/node-polyfill-fetch.js'\r\n\r\nimport middlewareChunkGroup from 'MIDDLEWARE_CHUNK_GROUP'\r\nimport middlewareConfig from 'MIDDLEWARE_CONFIG'\r\n\r\ntype Resolver = Awaited<\r\n  ReturnType<typeof import('next/dist/server/lib/route-resolver').makeResolver>\r\n>\r\n\r\ntype RouterRequest = {\r\n  method: string\r\n  pathname: string\r\n  rawHeaders: [string, string][]\r\n  rawQuery: string\r\n  body: number[][]\r\n}\r\n\r\ntype IpcOutgoingMessage = {\r\n  type: 'value'\r\n  data: string | Buffer\r\n}\r\n\r\ntype MessageData =\r\n  | { type: 'middleware-headers'; data: MiddlewareHeadersResponse }\r\n  | { type: 'middleware-body'; data: Uint8Array }\r\n  | {\r\n      type: 'rewrite'\r\n      data: RewriteResponse\r\n    }\r\n  | {\r\n      type: 'error'\r\n      error: StructuredError\r\n    }\r\n  | { type: 'none' }\r\n\r\ntype RewriteResponse = {\r\n  url: string\r\n  headers: [string, string][]\r\n}\r\n\r\ntype MiddlewareHeadersResponse = {\r\n  statusCode: number\r\n  headers: [string, string][]\r\n}\r\n\r\nlet resolveRouteMemo: Promise<Resolver>\r\n\r\nasync function getResolveRoute(\r\n  dir: string,\r\n  serverInfo: ServerInfo\r\n): Promise<Resolver> {\r\n  const nextConfig = await loadConfig(\r\n    PHASE_DEVELOPMENT_SERVER,\r\n    process.cwd(),\r\n    undefined,\r\n    undefined,\r\n    true\r\n  )\r\n  const middlewareCfg = {\r\n    files: middlewareChunkGroup.filter((f) => /\\.[mc]?js$/.test(f)),\r\n    matcher: middlewareConfig.matcher,\r\n  }\r\n\r\n  return await makeResolver(dir, nextConfig, middlewareCfg, serverInfo)\r\n}\r\n\r\nexport default async function route(\r\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\r\n  routerRequest: RouterRequest,\r\n  dir: string,\r\n  serverInfo: ServerInfo\r\n) {\r\n  const [resolveRoute, server] = await Promise.all([\r\n    (resolveRouteMemo ??= getResolveRoute(dir, serverInfo)),\r\n    createServer(),\r\n  ])\r\n\r\n  try {\r\n    const {\r\n      clientRequest,\r\n      clientResponsePromise,\r\n      serverRequest,\r\n      serverResponse,\r\n    } = await makeRequest(\r\n      server,\r\n      routerRequest.method,\r\n      routerRequest.pathname,\r\n      routerRequest.rawQuery,\r\n      routerRequest.rawHeaders,\r\n      serverInfo\r\n    )\r\n\r\n    const body = Buffer.concat(\r\n      routerRequest.body.map((arr) => Buffer.from(arr))\r\n    )\r\n\r\n    // Send the clientRequest, so the server parses everything. We can then pass\r\n    // the serverRequest to Next.js to handle.\r\n    clientRequest.end(body)\r\n\r\n    // The route promise must not block us from starting the middleware\r\n    // response handling, so we cannot await it yet. By making the call, we\r\n    // allow Next.js to start writing to the response whenever it's ready.\r\n    const routePromise = resolveRoute(serverRequest, serverResponse)\r\n\r\n    // Now that the Next.js has started processing the route, the middleware\r\n    // response promise will resolve once they write data and then we can begin\r\n    // streaming.\r\n    // We again cannot await directly on the promise, because an error may\r\n    // occur in the routePromise while we're waiting.\r\n    const middlewarePromise = clientResponsePromise.then((c) =>\r\n      handleMiddlewareResponse(ipc, c)\r\n    )\r\n\r\n    // Now that both promises are in progress, we await both so that a\r\n    // rejection in either will end the routing.\r\n    const [routeResult] = await Promise.all([routePromise, middlewarePromise])\r\n\r\n    server.close()\r\n\r\n    if (routeResult) {\r\n      switch (routeResult.type) {\r\n        case 'none':\r\n        case 'error':\r\n          return routeResult\r\n        case 'rewrite':\r\n          return {\r\n            type: 'rewrite',\r\n            data: {\r\n              url: routeResult.url,\r\n              headers: Object.entries(routeResult.headers)\r\n                .filter(([, val]) => val != null)\r\n                .map(([name, value]) => [name, value!.toString()]),\r\n            },\r\n          }\r\n        default:\r\n          // @ts-expect-error data.type is never\r\n          throw new Error(`unknown route result type: ${data.type}`)\r\n      }\r\n    }\r\n  } catch (e) {\r\n    // Server doesn't need to be closed, because the sendError will terminate\r\n    // the process.\r\n    ipc.sendError(e as Error)\r\n  }\r\n}\r\n\r\nasync function handleMiddlewareResponse(\r\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\r\n  clientResponse: IncomingMessage\r\n): Promise<void> {\r\n  // If this header is specified, we know that the response was not handled by\r\n  // middleware. The headers and body of the response are useless.\r\n  if (clientResponse.headers['x-nextjs-route-result']) {\r\n    return\r\n  }\r\n\r\n  const responseHeaders: MiddlewareHeadersResponse = {\r\n    statusCode: clientResponse.statusCode!,\r\n    headers: toPairs(clientResponse.rawHeaders),\r\n  }\r\n\r\n  await ipc.send({\r\n    type: 'value',\r\n    data: JSON.stringify({\r\n      type: 'middleware-headers',\r\n      data: responseHeaders,\r\n    }),\r\n  })\r\n\r\n  for await (const chunk of clientResponse) {\r\n    await ipc.send({\r\n      type: 'value',\r\n      data: JSON.stringify({\r\n        type: 'middleware-body',\r\n        data: (chunk as Buffer).toJSON().data,\r\n      }),\r\n    })\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsDA,IAAI;AAEJ,eAAe,gBACb,GAAW,EACX,UAAsB;IAEtB,MAAM,aAAa,MAAM,sKAEvB,QAAQ,GAAG,IACX,WACA,WACA;IAEF,MAAM,gBAAgB;QACpB,OAAO,kGAAqB,MAAM,CAAC,CAAC,IAAM,aAAa,IAAI,CAAC;QAC5D,SAAS,yGAAiB,OAAO;IACnC;IAEA,OAAO,MAAM,4FAAa,KAAK,YAAY,eAAe;AAC5D;AAEe,eAAe,MAC5B,GAA2C,EAC3C,aAA4B,EAC5B,GAAW,EACX,UAAsB;IAEtB,MAAM,CAAC,cAAc,OAAO,GAAG,MAAM,QAAQ,GAAG,CAAC;QAC9C,qBAAqB,gBAAgB,KAAK;QAC3C;KACD;IAED,IAAI;QACF,MAAM,EACJ,aAAa,EACb,qBAAqB,EACrB,aAAa,EACb,cAAc,EACf,GAAG,MAAM,2GACR,QACA,cAAc,MAAM,EACpB,cAAc,QAAQ,EACtB,cAAc,QAAQ,EACtB,cAAc,UAAU,EACxB;QAGF,MAAM,OAAO,kDAAO,MAAM,CACxB,cAAc,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,kDAAO,IAAI,CAAC;QAK9C,cAAc,GAAG,CAAC;QAKlB,MAAM,eAAe,aAAa,eAAe;QAOjD,MAAM,oBAAoB,sBAAsB,IAAI,CAAC,CAAC,IACpD,yBAAyB,KAAK;QAKhC,MAAM,CAAC,YAAY,GAAG,MAAM,QAAQ,GAAG,CAAC;YAAC;YAAc;SAAkB;QAEzE,OAAO,KAAK;QAEZ,IAAI,aAAa;YACf,OAAQ,YAAY,IAAI;gBACtB,KAAK;gBACL,KAAK;oBACH,OAAO;gBACT,KAAK;oBACH,OAAO;wBACL,MAAM;wBACN,MAAM;4BACJ,KAAK,YAAY,GAAG;4BACpB,SAAS,OAAO,OAAO,CAAC,YAAY,OAAO,EACxC,MAAM,CAAC,CAAC,GAAG,IAAI,GAAK,OAAO,MAC3B,GAAG,CAAC,CAAC,CAAC,MAAM,MAAM,GAAK;oCAAC;oCAAM,MAAO,QAAQ;iCAAG;wBACrD;oBACF;gBACF;oBAEE,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,KAAK,IAAI,CAAC,CAAC;YAC7D;QACF;IACF,EAAE,OAAO,GAAG;QAGV,IAAI,SAAS,CAAC;IAChB;AACF;AAEA,eAAe,yBACb,GAA2C,EAC3C,cAA+B;IAI/B,IAAI,eAAe,OAAO,CAAC,wBAAwB,EAAE;QACnD;IACF;IAEA,MAAM,kBAA6C;QACjD,YAAY,eAAe,UAAU;QACrC,SAAS,wGAAQ,eAAe,UAAU;IAC5C;IAEA,MAAM,IAAI,IAAI,CAAC;QACb,MAAM;QACN,MAAM,KAAK,SAAS,CAAC;YACnB,MAAM;YACN,MAAM;QACR;IACF;IAEA,WAAW,MAAM,SAAS,eAAgB;QACxC,MAAM,IAAI,IAAI,CAAC;YACb,MAAM;YACN,MAAM,KAAK,SAAS,CAAC;gBACnB,MAAM;gBACN,MAAM,AAAC,MAAiB,MAAM,GAAG,IAAI;YACvC;QACF;IACF;AACF"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}