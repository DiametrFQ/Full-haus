{
  "version": 3,
  "sections": [
    {"offset": {"line": 9, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @next/next/no-assign-module-variable */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ninterface Exports {\n  __esModule?: boolean;\n\n  [key: string]: any;\n}\ntype EsmNamespaceObject = Record<string, any>;\n\ninterface BaseModule {\n  exports: Exports;\n  error: Error | undefined;\n  loaded: boolean;\n  id: ModuleId;\n  children: ModuleId[];\n  parents: ModuleId[];\n  namespaceObject?: EsmNamespaceObject;\n}\n\ninterface Module extends BaseModule {}\n\ntype RequireContextMap = Record<ModuleId, RequireContextEntry>;\n\ninterface RequireContextEntry {\n  id: () => ModuleId;\n}\n\ninterface RequireContext {\n  (moduleId: ModuleId): Exports | EsmNamespaceObject;\n  keys(): ModuleId[];\n  resolve(moduleId: ModuleId): ModuleId;\n}\n\ntype GetOrInstantiateModuleFromParent = (\n  moduleId: ModuleId,\n  parentModule: Module\n) => Module;\n\ntype CommonJsRequireContext = (\n  entry: RequireContextEntry,\n  parentModule: Module\n) => Exports;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag;\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name))\n    Object.defineProperty(obj, name, options);\n}\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, getters: Record<string, () => any>) {\n  defineProp(exports, \"__esModule\", { value: true });\n  if (toStringTag) defineProp(exports, toStringTag, { value: \"Module\" });\n  for (const key in getters) {\n    defineProp(exports, key, { get: getters[key], enumerable: true });\n  }\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(module: Module, getters: Record<string, () => any>) {\n  esm((module.namespaceObject = module.exports), getters);\n}\n\n/**\n * Adds the props to the exports object\n */\nfunction cjsExport(exports: Exports, props: Record<string, any>) {\n  for (const key in props) {\n    defineProp(exports, key, { get: () => props[key], enumerable: true });\n  }\n}\n\nfunction exportValue(module: Module, value: any) {\n  module.exports = value;\n}\n\nfunction exportNamespace(module: Module, namespace: any) {\n  module.exports = module.namespaceObject = namespace;\n}\n\nfunction createGetter(obj: Record<string, any>, key: string) {\n  return () => obj[key];\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__;\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)];\n\n/**\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const getters: { [s: string]: () => any } = Object.create(null);\n  for (\n    let current = raw;\n    (typeof current === \"object\" || typeof current === \"function\") &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      getters[key] = createGetter(raw, key);\n    }\n  }\n  if (!(allowExportDefault && \"default\" in getters)) {\n    getters[\"default\"] = () => raw;\n  }\n  esm(ns, getters);\n}\n\nfunction esmImport(sourceModule: Module, id: ModuleId): EsmNamespaceObject {\n  const module = getOrInstantiateModuleFromParent(id, sourceModule);\n  if (module.error) throw module.error;\n  if (module.namespaceObject) return module.namespaceObject;\n  const raw = module.exports;\n  const ns = (module.namespaceObject = {});\n  interopEsm(raw, ns, raw.__esModule);\n  return ns;\n}\n\nfunction commonJsRequire(sourceModule: Module, id: ModuleId): Exports {\n  const module = getOrInstantiateModuleFromParent(id, sourceModule);\n  if (module.error) throw module.error;\n  return module.exports;\n}\n\ntype RequireContextFactory = (map: RequireContextMap) => RequireContext;\n\nfunction requireContext(\n  sourceModule: Module,\n  map: RequireContextMap\n): RequireContext {\n  function requireContext(id: ModuleId): Exports {\n    const entry = map[id];\n\n    if (!entry) {\n      throw new Error(\n        `module ${id} is required from a require.context, but is not in the context`\n      );\n    }\n\n    return commonJsRequireContext(entry, sourceModule);\n  }\n\n  requireContext.keys = (): ModuleId[] => {\n    return Object.keys(map);\n  };\n\n  requireContext.resolve = (id: ModuleId): ModuleId => {\n    const entry = map[id];\n\n    if (!entry) {\n      throw new Error(\n        `module ${id} is resolved from a require.context, but is not in the context`\n      );\n    }\n\n    return entry.id();\n  };\n\n  return requireContext;\n}\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === \"string\" ? chunkData : chunkData.path;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/dev/runtime/base/runtime-base.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *development* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @next/next/no-assign-module-variable */\n\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\n/// <reference path=\"./globals.d.ts\" />\n/// <reference path=\"./protocol.d.ts\" />\n/// <reference path=\"./extensions.d.ts\" />\n\n// This file must not use `import` and `export` statements. Otherwise, it\n// becomes impossible to augment interfaces declared in `<reference>`d files\n// (e.g. `Module`). Hence, the need for `import()` here.\ntype RefreshRuntimeGlobals =\n  import(\"@next/react-refresh-utils/dist/runtime\").RefreshRuntimeGlobals;\n\ndeclare var $RefreshHelpers$: RefreshRuntimeGlobals[\"$RefreshHelpers$\"];\ndeclare var $RefreshReg$: RefreshRuntimeGlobals[\"$RefreshReg$\"];\ndeclare var $RefreshSig$: RefreshRuntimeGlobals[\"$RefreshSig$\"];\ndeclare var $RefreshInterceptModuleExecution$:\n  | RefreshRuntimeGlobals[\"$RefreshInterceptModuleExecution$\"];\n\ntype RefreshContext = {\n  register: RefreshRuntimeGlobals[\"$RefreshReg$\"];\n  signature: RefreshRuntimeGlobals[\"$RefreshSig$\"];\n};\n\ntype RefreshHelpers = RefreshRuntimeGlobals[\"$RefreshHelpers$\"];\n\ninterface TurbopackDevBaseContext {\n  e: Module[\"exports\"];\n  r: CommonJsRequire;\n  f: RequireContextFactory;\n  i: EsmImport;\n  s: EsmExport;\n  j: typeof cjsExport;\n  v: ExportValue;\n  n: typeof exportNamespace;\n  m: Module;\n  c: ModuleCache;\n  l: LoadChunk;\n  g: typeof globalThis;\n  k: RefreshContext;\n  __dirname: string;\n}\n\ninterface TurbopackDevContext extends TurbopackDevBaseContext {}\n\n// string encoding of a module factory (used in hmr updates)\ntype ModuleFactoryString = string;\n\ntype ModuleFactory = (\n  this: Module[\"exports\"],\n  context: TurbopackDevContext\n) => undefined;\n\ntype DevRuntimeParams = {\n  otherChunks: ChunkData[];\n  runtimeModuleIds: ModuleId[];\n};\n\ntype ChunkRegistration = [\n  chunkPath: ChunkPath,\n  chunkModules: ModuleFactories,\n  params: DevRuntimeParams | undefined\n];\ntype ChunkList = {\n  path: ChunkPath;\n  chunks: ChunkData[];\n  source: \"entry\" | \"dynamic\";\n};\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   */\n  Update = 2,\n}\n\ntype SourceInfo =\n  | {\n      type: SourceType.Runtime;\n      chunkPath: ChunkPath;\n    }\n  | {\n      type: SourceType.Parent;\n      parentId: ModuleId;\n    }\n  | {\n      type: SourceType.Update;\n      parents?: ModuleId[];\n    };\n\ninterface RuntimeBackend {\n  registerChunk: (chunkPath: ChunkPath, params?: DevRuntimeParams) => void;\n  loadChunk: (chunkPath: ChunkPath, source: SourceInfo) => Promise<void>;\n  reloadChunk?: (chunkPath: ChunkPath) => Promise<void>;\n  unloadChunk?: (chunkPath: ChunkPath) => void;\n\n  restart: () => void;\n}\n\nconst moduleFactories: ModuleFactories = Object.create(null);\nconst moduleCache: ModuleCache = Object.create(null);\n/**\n * Maps module IDs to persisted data between executions of their hot module\n * implementation (`hot.data`).\n */\nconst moduleHotData: Map<ModuleId, HotData> = new Map();\n/**\n * Maps module instances to their hot module state.\n */\nconst moduleHotState: Map<Module, HotState> = new Map();\n/**\n * Modules that call `module.hot.invalidate()` (while being updated).\n */\nconst queuedInvalidatedModules: Set<ModuleId> = new Set();\n/**\n * Module IDs that are instantiated as part of the runtime of a chunk.\n */\nconst runtimeModules: Set<ModuleId> = new Set();\n/**\n * Map from module ID to the chunks that contain this module.\n *\n * In HMR, we need to keep track of which modules are contained in which so\n * chunks. This is so we don't eagerly dispose of a module when it is removed\n * from chunk A, but still exists in chunk B.\n */\nconst moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map();\n/**\n * Map from a chunk path to all modules it contains.\n */\nconst chunkModulesMap: Map<ModuleId, Set<ChunkPath>> = new Map();\n/**\n * Chunk lists that contain a runtime. When these chunk lists receive an update\n * that can't be reconciled with the current state of the page, we need to\n * reload the runtime entirely.\n */\nconst runtimeChunkLists: Set<ChunkPath> = new Set();\n/**\n * Map from a chunk list to the chunk paths it contains.\n */\nconst chunkListChunksMap: Map<ChunkPath, Set<ChunkPath>> = new Map();\n/**\n * Map from a chunk path to the chunk lists it belongs to.\n */\nconst chunkChunkListsMap: Map<ChunkPath, Set<ChunkPath>> = new Map();\n\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map();\n\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map();\n\nasync function loadChunk(\n  source: SourceInfo,\n  chunkData: ChunkData\n): Promise<any> {\n  if (typeof chunkData === \"string\") {\n    return loadChunkPath(source, chunkData);\n  }\n\n  const includedList = chunkData.included || [];\n  const modulesPromises = includedList.map((included) => {\n    if (moduleFactories[included]) return true;\n    return availableModules.get(included);\n  });\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\n    // When all included items are already loaded or loading, we can skip loading ourselves\n    return Promise.all(modulesPromises);\n  }\n\n  const includedModuleChunksList = chunkData.moduleChunks || [];\n  const moduleChunksPromises = includedModuleChunksList\n    .map((included) => {\n      // TODO(alexkirsz) Do we need this check?\n      // if (moduleFactories[included]) return true;\n      return availableModuleChunks.get(included);\n    })\n    .filter((p) => p);\n\n  let promise;\n  if (moduleChunksPromises.length > 0) {\n    // Some module chunks are already loaded or loading.\n\n    if (moduleChunksPromises.length == includedModuleChunksList.length) {\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\n      return Promise.all(moduleChunksPromises);\n    }\n\n    const moduleChunksToLoad: Set<ChunkPath> = new Set();\n    for (const moduleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(moduleChunk)) {\n        moduleChunksToLoad.add(moduleChunk);\n      }\n    }\n\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\n      const promise = loadChunkPath(source, moduleChunkToLoad);\n\n      availableModuleChunks.set(moduleChunkToLoad, promise);\n\n      moduleChunksPromises.push(promise);\n    }\n\n    promise = Promise.all(moduleChunksPromises);\n  } else {\n    promise = loadChunkPath(source, chunkData.path);\n\n    // Mark all included module chunks as loading if they are not already loaded or loading.\n    for (const includedModuleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(includedModuleChunk)) {\n        availableModuleChunks.set(includedModuleChunk, promise);\n      }\n    }\n  }\n\n  for (const included of includedList) {\n    if (!availableModules.has(included)) {\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n      availableModules.set(included, promise);\n    }\n  }\n\n  return promise;\n}\n\nasync function loadChunkPath(\n  source: SourceInfo,\n  chunkPath: ChunkPath\n): Promise<any> {\n  try {\n    await BACKEND.loadChunk(chunkPath, source);\n  } catch (error) {\n    let loadReason;\n    switch (source.type) {\n      case SourceType.Runtime:\n        loadReason = `as a runtime dependency of chunk ${source.chunkPath}`;\n        break;\n      case SourceType.Parent:\n        loadReason = `from module ${source.parentId}`;\n        break;\n      case SourceType.Update:\n        loadReason = \"from an HMR update\";\n        break;\n    }\n    throw new Error(\n      `Failed to load chunk ${chunkPath} ${loadReason}${\n        error ? `: ${error}` : \"\"\n      }`,\n      error\n        ? {\n            cause: error,\n          }\n        : undefined\n    );\n  }\n}\n\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\n  const moduleFactory = moduleFactories[id];\n  if (typeof moduleFactory !== \"function\") {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    let instantiationReason;\n    switch (source.type) {\n      case SourceType.Runtime:\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\n        break;\n      case SourceType.Parent:\n        instantiationReason = `because it was required from module ${source.parentId}`;\n        break;\n      case SourceType.Update:\n        instantiationReason = \"because of an HMR update\";\n        break;\n    }\n    throw new Error(\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\n    );\n  }\n\n  const hotData = moduleHotData.get(id)!;\n  const { hot, hotState } = createModuleHot(id, hotData);\n\n  let parents: ModuleId[];\n  switch (source.type) {\n    case SourceType.Runtime:\n      runtimeModules.add(id);\n      parents = [];\n      break;\n    case SourceType.Parent:\n      // No need to add this module as a child of the parent module here, this\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\n      parents = [source.parentId];\n      break;\n    case SourceType.Update:\n      parents = source.parents || [];\n      break;\n  }\n  const module: Module = {\n    exports: {},\n    error: undefined,\n    loaded: false,\n    id,\n    parents,\n    children: [],\n    namespaceObject: undefined,\n    hot,\n  };\n\n  moduleCache[id] = module;\n  moduleHotState.set(module, hotState);\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    runModuleExecutionHooks(module, (refresh) => {\n      moduleFactory.call(\n        module.exports,\n        augmentContext({\n          e: module.exports,\n          r: commonJsRequire.bind(null, module),\n          f: requireContext.bind(null, module),\n          i: esmImport.bind(null, module),\n          s: esmExport.bind(null, module),\n          j: cjsExport.bind(null, module.exports),\n          v: exportValue.bind(null, module),\n          n: exportNamespace.bind(null, module),\n          m: module,\n          c: moduleCache,\n          l: loadChunk.bind(null, { type: SourceType.Parent, parentId: id }),\n          g: globalThis,\n          k: refresh,\n          __dirname: module.id.replace(/(^|\\/)\\/+$/, \"\"),\n        })\n      );\n    });\n  } catch (error) {\n    module.error = error as any;\n    throw error;\n  }\n\n  module.loaded = true;\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject);\n  }\n\n  return module;\n}\n\n/**\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\n * Next.js' React Refresh runtime hooks into to add module context to the\n * refresh registry.\n */\nfunction runModuleExecutionHooks(\n  module: Module,\n  executeModule: (ctx: RefreshContext) => void\n) {\n  const cleanupReactRefreshIntercept =\n    typeof globalThis.$RefreshInterceptModuleExecution$ === \"function\"\n      ? globalThis.$RefreshInterceptModuleExecution$(module.id)\n      : () => {};\n\n  try {\n    executeModule({\n      register: globalThis.$RefreshReg$,\n      signature: globalThis.$RefreshSig$,\n    });\n\n    if (\"$RefreshHelpers$\" in globalThis) {\n      // This pattern can also be used to register the exports of\n      // a module with the React Refresh runtime.\n      registerExportsAndSetupBoundaryForReactRefresh(\n        module,\n        globalThis.$RefreshHelpers$\n      );\n    }\n  } catch (e) {\n    throw e;\n  } finally {\n    // Always cleanup the intercept, even if module execution failed.\n    cleanupReactRefreshIntercept();\n  }\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent = (\n  id,\n  sourceModule\n) => {\n  if (!sourceModule.hot.active) {\n    console.warn(\n      `Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`\n    );\n  }\n\n  const module = moduleCache[id];\n\n  if (sourceModule.children.indexOf(id) === -1) {\n    sourceModule.children.push(id);\n  }\n\n  if (module) {\n    if (module.parents.indexOf(sourceModule.id) === -1) {\n      module.parents.push(sourceModule.id);\n    }\n\n    return module;\n  }\n\n  return instantiateModule(id, {\n    type: SourceType.Parent,\n    parentId: sourceModule.id,\n  });\n};\n\n/**\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\n */\nfunction registerExportsAndSetupBoundaryForReactRefresh(\n  module: Module,\n  helpers: RefreshHelpers\n) {\n  const currentExports = module.exports;\n  const prevExports = module.hot.data.prevExports ?? null;\n\n  helpers.registerExportsForReactRefresh(currentExports, module.id);\n\n  // A module can be accepted automatically based on its exports, e.g. when\n  // it is a Refresh Boundary.\n  if (helpers.isReactRefreshBoundary(currentExports)) {\n    // Save the previous exports on update, so we can compare the boundary\n    // signatures.\n    module.hot.dispose((data) => {\n      data.prevExports = currentExports;\n    });\n    // Unconditionally accept an update to this module, we'll check if it's\n    // still a Refresh Boundary later.\n    module.hot.accept();\n\n    // This field is set when the previous version of this module was a\n    // Refresh Boundary, letting us know we need to check for invalidation or\n    // enqueue an update.\n    if (prevExports !== null) {\n      // A boundary can become ineligible if its exports are incompatible\n      // with the previous exports.\n      //\n      // For example, if you add/remove/change exports, we'll want to\n      // re-execute the importing modules, and force those components to\n      // re-render. Similarly, if you convert a class component to a\n      // function, we want to invalidate the boundary.\n      if (\n        helpers.shouldInvalidateReactRefreshBoundary(\n          prevExports,\n          currentExports\n        )\n      ) {\n        module.hot.invalidate();\n      } else {\n        helpers.scheduleUpdate();\n      }\n    }\n  } else {\n    // Since we just executed the code for the module, it's possible that the\n    // new exports made it ineligible for being a boundary.\n    // We only care about the case when we were _previously_ a boundary,\n    // because we already accepted this update (accidental side effect).\n    const isNoLongerABoundary = prevExports !== null;\n    if (isNoLongerABoundary) {\n      module.hot.invalidate();\n    }\n  }\n}\n\nfunction formatDependencyChain(dependencyChain: ModuleId[]): string {\n  return `Dependency chain: ${dependencyChain.join(\" -> \")}`;\n}\n\nfunction computeOutdatedModules(\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>,\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n): {\n  outdatedModules: Set<ModuleId>;\n  newModuleFactories: Map<ModuleId, ModuleFactory>;\n} {\n  const newModuleFactories = new Map<ModuleId, ModuleFactory>();\n\n  for (const [moduleId, entry] of added) {\n    if (entry != null) {\n      newModuleFactories.set(moduleId, _eval(entry));\n    }\n  }\n\n  const outdatedModules = computedInvalidatedModules(modified.keys());\n\n  for (const [moduleId, entry] of modified) {\n    newModuleFactories.set(moduleId, _eval(entry));\n  }\n\n  return { outdatedModules, newModuleFactories };\n}\n\nfunction computedInvalidatedModules(\n  invalidated: Iterable<ModuleId>\n): Set<ModuleId> {\n  const outdatedModules = new Set<ModuleId>();\n\n  for (const moduleId of invalidated) {\n    const effect = getAffectedModuleEffects(moduleId);\n\n    switch (effect.type) {\n      case \"unaccepted\":\n        throw new Error(\n          `cannot apply update: unaccepted module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`\n        );\n      case \"self-declined\":\n        throw new Error(\n          `cannot apply update: self-declined module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`\n        );\n      case \"accepted\":\n        for (const outdatedModuleId of effect.outdatedModules) {\n          outdatedModules.add(outdatedModuleId);\n        }\n        break;\n      // TODO(alexkirsz) Dependencies: handle dependencies effects.\n    }\n  }\n\n  return outdatedModules;\n}\n\nfunction computeOutdatedSelfAcceptedModules(\n  outdatedModules: Iterable<ModuleId>\n): { moduleId: ModuleId; errorHandler: true | Function }[] {\n  const outdatedSelfAcceptedModules = [];\n  for (const moduleId of outdatedModules) {\n    const module = moduleCache[moduleId];\n    const hotState = moduleHotState.get(module)!;\n    if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n      outdatedSelfAcceptedModules.push({\n        moduleId,\n        errorHandler: hotState.selfAccepted,\n      });\n    }\n  }\n  return outdatedSelfAcceptedModules;\n}\n\n/**\n * Adds, deletes, and moves modules between chunks. This must happen before the\n * dispose phase as it needs to know which modules were removed from all chunks,\n * which we can only compute *after* taking care of added and moved modules.\n */\nfunction updateChunksPhase(\n  chunksAddedModules: Map<ChunkPath, Set<ModuleId>>,\n  chunksDeletedModules: Map<ChunkPath, Set<ModuleId>>\n): { disposedModules: Set<ModuleId> } {\n  for (const [chunkPath, addedModuleIds] of chunksAddedModules) {\n    for (const moduleId of addedModuleIds) {\n      addModuleToChunk(moduleId, chunkPath);\n    }\n  }\n\n  const disposedModules: Set<ModuleId> = new Set();\n  for (const [chunkPath, addedModuleIds] of chunksDeletedModules) {\n    for (const moduleId of addedModuleIds) {\n      if (removeModuleFromChunk(moduleId, chunkPath)) {\n        disposedModules.add(moduleId);\n      }\n    }\n  }\n\n  return { disposedModules };\n}\n\nfunction disposePhase(\n  outdatedModules: Iterable<ModuleId>,\n  disposedModules: Iterable<ModuleId>\n): { outdatedModuleParents: Map<ModuleId, Array<ModuleId>> } {\n  for (const moduleId of outdatedModules) {\n    disposeModule(moduleId, \"replace\");\n  }\n\n  for (const moduleId of disposedModules) {\n    disposeModule(moduleId, \"clear\");\n  }\n\n  // Removing modules from the module cache is a separate step.\n  // We also want to keep track of previous parents of the outdated modules.\n  const outdatedModuleParents = new Map();\n  for (const moduleId of outdatedModules) {\n    const oldModule = moduleCache[moduleId];\n    outdatedModuleParents.set(moduleId, oldModule?.parents);\n    delete moduleCache[moduleId];\n  }\n\n  // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n  // children.\n\n  return { outdatedModuleParents };\n}\n\n/**\n * Disposes of an instance of a module.\n *\n * Returns the persistent hot data that should be kept for the next module\n * instance.\n *\n * NOTE: mode = \"replace\" will not remove modules from the moduleCache.\n * This must be done in a separate step afterwards.\n * This is important because all modules need to be disposed to update the\n * parent/child relationships before they are actually removed from the moduleCache.\n * If this was done in this method, the following disposeModule calls won't find\n * the module from the module id in the cache.\n */\nfunction disposeModule(moduleId: ModuleId, mode: \"clear\" | \"replace\") {\n  const module = moduleCache[moduleId];\n  if (!module) {\n    return;\n  }\n\n  const hotState = moduleHotState.get(module)!;\n  const data = {};\n\n  // Run the `hot.dispose` handler, if any, passing in the persistent\n  // `hot.data` object.\n  for (const disposeHandler of hotState.disposeHandlers) {\n    disposeHandler(data);\n  }\n\n  // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n  // module is still importing other modules.\n  module.hot.active = false;\n\n  moduleHotState.delete(module);\n\n  // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n\n  // Remove the disposed module from its children's parent list.\n  // It will be added back once the module re-instantiates and imports its\n  // children again.\n  for (const childId of module.children) {\n    const child = moduleCache[childId];\n    if (!child) {\n      continue;\n    }\n\n    const idx = child.parents.indexOf(module.id);\n    if (idx >= 0) {\n      child.parents.splice(idx, 1);\n    }\n  }\n\n  switch (mode) {\n    case \"clear\":\n      delete moduleCache[module.id];\n      moduleHotData.delete(module.id);\n      break;\n    case \"replace\":\n      moduleHotData.set(module.id, data);\n      break;\n    default:\n      invariant(mode, (mode) => `invalid mode: ${mode}`);\n  }\n}\n\nfunction applyPhase(\n  outdatedSelfAcceptedModules: {\n    moduleId: ModuleId;\n    errorHandler: true | Function;\n  }[],\n  newModuleFactories: Map<ModuleId, ModuleFactory>,\n  outdatedModuleParents: Map<ModuleId, Array<ModuleId>>,\n  reportError: (err: any) => void\n) {\n  // Update module factories.\n  for (const [moduleId, factory] of newModuleFactories.entries()) {\n    moduleFactories[moduleId] = factory;\n  }\n\n  // TODO(alexkirsz) Run new runtime entries here.\n\n  // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n\n  // Re-instantiate all outdated self-accepted modules.\n  for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\n    try {\n      instantiateModule(moduleId, {\n        type: SourceType.Update,\n        parents: outdatedModuleParents.get(moduleId),\n      });\n    } catch (err) {\n      if (typeof errorHandler === \"function\") {\n        try {\n          errorHandler(err, { moduleId, module: moduleCache[moduleId] });\n        } catch (err2) {\n          reportError(err2);\n          reportError(err);\n        }\n      } else {\n        reportError(err);\n      }\n    }\n  }\n}\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`);\n}\n\nfunction applyUpdate(chunkListPath: ChunkPath, update: PartialUpdate) {\n  switch (update.type) {\n    case \"ChunkListUpdate\":\n      applyChunkListUpdate(chunkListPath, update);\n      break;\n    default:\n      invariant(update, (update) => `Unknown update type: ${update.type}`);\n  }\n}\n\nfunction applyChunkListUpdate(\n  chunkListPath: ChunkPath,\n  update: ChunkListUpdate\n) {\n  if (update.merged != null) {\n    for (const merged of update.merged) {\n      switch (merged.type) {\n        case \"EcmascriptMergedUpdate\":\n          applyEcmascriptMergedUpdate(chunkListPath, merged);\n          break;\n        default:\n          invariant(merged, (merged) => `Unknown merged type: ${merged.type}`);\n      }\n    }\n  }\n\n  if (update.chunks != null) {\n    for (const [chunkPath, chunkUpdate] of Object.entries(update.chunks)) {\n      switch (chunkUpdate.type) {\n        case \"added\":\n          BACKEND.loadChunk(chunkPath, { type: SourceType.Update });\n          break;\n        case \"total\":\n          BACKEND.reloadChunk?.(chunkPath);\n          break;\n        case \"deleted\":\n          BACKEND.unloadChunk?.(chunkPath);\n          break;\n        case \"partial\":\n          invariant(\n            chunkUpdate.instruction,\n            (instruction) =>\n              `Unknown partial instruction: ${JSON.stringify(instruction)}.`\n          );\n        default:\n          invariant(\n            chunkUpdate,\n            (chunkUpdate) => `Unknown chunk update type: ${chunkUpdate.type}`\n          );\n      }\n    }\n  }\n}\n\nfunction applyEcmascriptMergedUpdate(\n  chunkPath: ChunkPath,\n  update: EcmascriptMergedUpdate\n) {\n  const { entries = {}, chunks = {} } = update;\n  const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(\n    entries,\n    chunks\n  );\n  const { outdatedModules, newModuleFactories } = computeOutdatedModules(\n    added,\n    modified\n  );\n  const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted);\n\n  applyInternal(outdatedModules, disposedModules, newModuleFactories);\n}\n\nfunction applyInvalidatedModules(outdatedModules: Set<ModuleId>) {\n  if (queuedInvalidatedModules.size > 0) {\n    computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId) => {\n      outdatedModules.add(moduleId);\n    });\n\n    queuedInvalidatedModules.clear();\n  }\n\n  return outdatedModules;\n}\n\nfunction applyInternal(\n  outdatedModules: Set<ModuleId>,\n  disposedModules: Iterable<ModuleId>,\n  newModuleFactories: Map<ModuleId, ModuleFactory>\n) {\n  outdatedModules = applyInvalidatedModules(outdatedModules);\n\n  const outdatedSelfAcceptedModules =\n    computeOutdatedSelfAcceptedModules(outdatedModules);\n\n  const { outdatedModuleParents } = disposePhase(\n    outdatedModules,\n    disposedModules\n  );\n\n  // we want to continue on error and only throw the error after we tried applying all updates\n  let error: any;\n  function reportError(err: any) {\n    if (!error) error = err;\n  }\n\n  applyPhase(\n    outdatedSelfAcceptedModules,\n    newModuleFactories,\n    outdatedModuleParents,\n    reportError\n  );\n\n  if (error) {\n    throw error;\n  }\n\n  if (queuedInvalidatedModules.size > 0) {\n    applyInternal(new Set(), [], new Map());\n  }\n}\n\nfunction computeChangedModules(\n  entries: Record<ModuleId, EcmascriptModuleEntry>,\n  updates: Record<ChunkPath, EcmascriptMergedChunkUpdate>\n): {\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>;\n  modified: Map<ModuleId, EcmascriptModuleEntry>;\n  deleted: Set<ModuleId>;\n  chunksAdded: Map<ChunkPath, Set<ModuleId>>;\n  chunksDeleted: Map<ChunkPath, Set<ModuleId>>;\n} {\n  const chunksAdded = new Map();\n  const chunksDeleted = new Map();\n  const added: Map<ModuleId, EcmascriptModuleEntry> = new Map();\n  const modified = new Map();\n  const deleted: Set<ModuleId> = new Set();\n\n  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates)) {\n    switch (mergedChunkUpdate.type) {\n      case \"added\": {\n        const updateAdded = new Set(mergedChunkUpdate.modules);\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId]);\n        }\n        chunksAdded.set(chunkPath, updateAdded);\n        break;\n      }\n      case \"deleted\": {\n        // We could also use `mergedChunkUpdate.modules` here.\n        const updateDeleted = new Set(chunkModulesMap.get(chunkPath));\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId);\n        }\n        chunksDeleted.set(chunkPath, updateDeleted);\n        break;\n      }\n      case \"partial\": {\n        const updateAdded = new Set(mergedChunkUpdate.added);\n        const updateDeleted = new Set(mergedChunkUpdate.deleted);\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId]);\n        }\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId);\n        }\n        chunksAdded.set(chunkPath, updateAdded);\n        chunksDeleted.set(chunkPath, updateDeleted);\n        break;\n      }\n      default:\n        invariant(\n          mergedChunkUpdate,\n          (mergedChunkUpdate) =>\n            `Unknown merged chunk update type: ${mergedChunkUpdate.type}`\n        );\n    }\n  }\n\n  // If a module was added from one chunk and deleted from another in the same update,\n  // consider it to be modified, as it means the module was moved from one chunk to another\n  // AND has new code in a single update.\n  for (const moduleId of added.keys()) {\n    if (deleted.has(moduleId)) {\n      added.delete(moduleId);\n      deleted.delete(moduleId);\n    }\n  }\n\n  for (const [moduleId, entry] of Object.entries(entries)) {\n    // Modules that haven't been added to any chunk but have new code are considered\n    // to be modified.\n    // This needs to be under the previous loop, as we need it to get rid of modules\n    // that were added and deleted in the same update.\n    if (!added.has(moduleId)) {\n      modified.set(moduleId, entry);\n    }\n  }\n\n  return { added, deleted, modified, chunksAdded, chunksDeleted };\n}\n\ntype ModuleEffect =\n  | {\n      type: \"unaccepted\";\n      dependencyChain: ModuleId[];\n    }\n  | {\n      type: \"self-declined\";\n      dependencyChain: ModuleId[];\n      moduleId: ModuleId;\n    }\n  | {\n      type: \"accepted\";\n      moduleId: ModuleId;\n      outdatedModules: Set<ModuleId>;\n    };\n\nfunction getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {\n  const outdatedModules: Set<ModuleId> = new Set();\n\n  type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] };\n\n  const queue: QueueItem[] = [\n    {\n      moduleId,\n      dependencyChain: [],\n    },\n  ];\n\n  let nextItem;\n  while ((nextItem = queue.shift())) {\n    const { moduleId, dependencyChain } = nextItem;\n\n    if (moduleId != null) {\n      outdatedModules.add(moduleId);\n    }\n\n    // We've arrived at the runtime of the chunk, which means that nothing\n    // else above can accept this update.\n    if (moduleId === undefined) {\n      return {\n        type: \"unaccepted\",\n        dependencyChain,\n      };\n    }\n\n    const module = moduleCache[moduleId];\n    const hotState = moduleHotState.get(module)!;\n\n    if (\n      // The module is not in the cache. Since this is a \"modified\" update,\n      // it means that the module was never instantiated before.\n      !module || // The module accepted itself without invalidating globalThis.\n      // TODO is that right?\n      (hotState.selfAccepted && !hotState.selfInvalidated)\n    ) {\n      continue;\n    }\n\n    if (hotState.selfDeclined) {\n      return {\n        type: \"self-declined\",\n        dependencyChain,\n        moduleId,\n      };\n    }\n\n    if (runtimeModules.has(moduleId)) {\n      queue.push({\n        moduleId: undefined,\n        dependencyChain: [...dependencyChain, moduleId],\n      });\n      continue;\n    }\n\n    for (const parentId of module.parents) {\n      const parent = moduleCache[parentId];\n\n      if (!parent) {\n        // TODO(alexkirsz) Is this even possible?\n        continue;\n      }\n\n      // TODO(alexkirsz) Dependencies: check accepted and declined\n      // dependencies here.\n\n      queue.push({\n        moduleId: parentId,\n        dependencyChain: [...dependencyChain, moduleId],\n      });\n    }\n  }\n\n  return {\n    type: \"accepted\",\n    moduleId,\n    outdatedModules,\n  };\n}\n\nfunction handleApply(chunkListPath: ChunkPath, update: ServerMessage) {\n  switch (update.type) {\n    case \"partial\": {\n      // This indicates that the update is can be applied to the current state of the application.\n      applyUpdate(chunkListPath, update.instruction);\n      break;\n    }\n    case \"restart\": {\n      // This indicates that there is no way to apply the update to the\n      // current state of the application, and that the application must be\n      // restarted.\n      BACKEND.restart();\n      break;\n    }\n    case \"notFound\": {\n      // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n      // or the page itself was deleted.\n      // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n      // If it is a runtime chunk list, we restart the application.\n      if (runtimeChunkLists.has(chunkListPath)) {\n        BACKEND.restart();\n      } else {\n        disposeChunkList(chunkListPath);\n      }\n      break;\n    }\n    default:\n      throw new Error(`Unknown update type: ${update.type}`);\n  }\n}\n\nfunction createModuleHot(\n  moduleId: ModuleId,\n  hotData: HotData\n): { hot: Hot; hotState: HotState } {\n  const hotState: HotState = {\n    selfAccepted: false,\n    selfDeclined: false,\n    selfInvalidated: false,\n    disposeHandlers: [],\n  };\n\n  const hot: Hot = {\n    // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n    // decide whether to warn whenever an HMR-disposed module required other\n    // modules. We might want to remove it.\n    active: true,\n\n    data: hotData ?? {},\n\n    // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n    accept: (\n      modules?: string | string[] | AcceptErrorHandler,\n      _callback?: AcceptCallback,\n      _errorHandler?: AcceptErrorHandler\n    ) => {\n      if (modules === undefined) {\n        hotState.selfAccepted = true;\n      } else if (typeof modules === \"function\") {\n        hotState.selfAccepted = modules;\n      } else {\n        throw new Error(\"unsupported `accept` signature\");\n      }\n    },\n\n    decline: (dep) => {\n      if (dep === undefined) {\n        hotState.selfDeclined = true;\n      } else {\n        throw new Error(\"unsupported `decline` signature\");\n      }\n    },\n\n    dispose: (callback) => {\n      hotState.disposeHandlers.push(callback);\n    },\n\n    addDisposeHandler: (callback) => {\n      hotState.disposeHandlers.push(callback);\n    },\n\n    removeDisposeHandler: (callback) => {\n      const idx = hotState.disposeHandlers.indexOf(callback);\n      if (idx >= 0) {\n        hotState.disposeHandlers.splice(idx, 1);\n      }\n    },\n\n    invalidate: () => {\n      hotState.selfInvalidated = true;\n      queuedInvalidatedModules.add(moduleId);\n    },\n\n    // NOTE(alexkirsz) This is part of the management API, which we don't\n    // implement, but the Next.js React Refresh runtime uses this to decide\n    // whether to schedule an update.\n    status: () => \"idle\",\n\n    // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n    addStatusHandler: (_handler) => {},\n    removeStatusHandler: (_handler) => {},\n  };\n\n  return { hot, hotState };\n}\n\n/**\n * Adds a module to a chunk.\n */\nfunction addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {\n  let moduleChunks = moduleChunksMap.get(moduleId);\n  if (!moduleChunks) {\n    moduleChunks = new Set([chunkPath]);\n    moduleChunksMap.set(moduleId, moduleChunks);\n  } else {\n    moduleChunks.add(chunkPath);\n  }\n\n  let chunkModules = chunkModulesMap.get(chunkPath);\n  if (!chunkModules) {\n    chunkModules = new Set([moduleId]);\n    chunkModulesMap.set(chunkPath, chunkModules);\n  } else {\n    chunkModules.add(moduleId);\n  }\n}\n\n/**\n * Returns the first chunk that included a module.\n * This is used by the Node.js backend, hence why it's marked as unused in this\n * file.\n */\nfunction getFirstModuleChunk(moduleId: ModuleId) {\n  const moduleChunkPaths = moduleChunksMap.get(moduleId);\n  if (moduleChunkPaths == null) {\n    return null;\n  }\n\n  return moduleChunkPaths.values().next().value;\n}\n\n/**\n * Removes a module from a chunk.\n * Returns `true` if there are no remaining chunks including this module.\n */\nfunction removeModuleFromChunk(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): boolean {\n  const moduleChunks = moduleChunksMap.get(moduleId)!;\n  moduleChunks.delete(chunkPath);\n\n  const chunkModules = chunkModulesMap.get(chunkPath)!;\n  chunkModules.delete(moduleId);\n\n  const noRemainingModules = chunkModules.size === 0;\n  if (noRemainingModules) {\n    chunkModulesMap.delete(chunkPath);\n  }\n\n  const noRemainingChunks = moduleChunks.size === 0;\n  if (noRemainingChunks) {\n    moduleChunksMap.delete(moduleId);\n  }\n\n  return noRemainingChunks;\n}\n\n/**\n * Disposes of a chunk list and its corresponding exclusive chunks.\n */\nfunction disposeChunkList(chunkListPath: ChunkPath): boolean {\n  const chunkPaths = chunkListChunksMap.get(chunkListPath);\n  if (chunkPaths == null) {\n    return false;\n  }\n  chunkListChunksMap.delete(chunkListPath);\n\n  for (const chunkPath of chunkPaths) {\n    const chunkChunkLists = chunkChunkListsMap.get(chunkPath)!;\n    chunkChunkLists.delete(chunkListPath);\n\n    if (chunkChunkLists.size === 0) {\n      chunkChunkListsMap.delete(chunkPath);\n      disposeChunk(chunkPath);\n    }\n  }\n\n  // We must also dispose of the chunk list's chunk itself to ensure it may\n  // be reloaded properly in the future.\n  BACKEND.unloadChunk?.(chunkListPath);\n\n  return true;\n}\n\n/**\n * Disposes of a chunk and its corresponding exclusive modules.\n *\n * @returns Whether the chunk was disposed of.\n */\nfunction disposeChunk(chunkPath: ChunkPath): boolean {\n  // This should happen whether the chunk has any modules in it or not.\n  // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n  BACKEND.unloadChunk?.(chunkPath);\n\n  const chunkModules = chunkModulesMap.get(chunkPath);\n  if (chunkModules == null) {\n    return false;\n  }\n  chunkModules.delete(chunkPath);\n\n  for (const moduleId of chunkModules) {\n    const moduleChunks = moduleChunksMap.get(moduleId)!;\n    moduleChunks.delete(chunkPath);\n\n    const noRemainingChunks = moduleChunks.size === 0;\n    if (noRemainingChunks) {\n      moduleChunksMap.delete(moduleId);\n      disposeModule(moduleId, \"clear\");\n      availableModules.delete(moduleId);\n    }\n  }\n\n  return true;\n}\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath });\n}\n\n/**\n * Gets or instantiates a runtime module.\n */\nfunction getOrInstantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  const module = moduleCache[moduleId];\n  if (module) {\n    if (module.error) {\n      throw module.error;\n    }\n    return module;\n  }\n\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath });\n}\n\n/**\n * Subscribes to chunk list updates from the update server and applies them.\n */\nfunction registerChunkList(\n  chunkUpdateProvider: ChunkUpdateProvider,\n  chunkList: ChunkList\n) {\n  chunkUpdateProvider.push([\n    chunkList.path,\n    handleApply.bind(null, chunkList.path),\n  ]);\n\n  // Adding chunks to chunk lists and vice versa.\n  const chunks = new Set(chunkList.chunks.map(getChunkPath));\n  chunkListChunksMap.set(chunkList.path, chunks);\n  for (const chunkPath of chunks) {\n    let chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n    if (!chunkChunkLists) {\n      chunkChunkLists = new Set([chunkList.path]);\n      chunkChunkListsMap.set(chunkPath, chunkChunkLists);\n    } else {\n      chunkChunkLists.add(chunkList.path);\n    }\n  }\n\n  if (chunkList.source === \"entry\") {\n    markChunkListAsRuntime(chunkList.path);\n  }\n}\n\n/**\n * Marks a chunk list as a runtime chunk list. There can be more than one\n * runtime chunk list. For instance, integration tests can have multiple chunk\n * groups loaded at runtime, each with its own chunk list.\n */\nfunction markChunkListAsRuntime(chunkListPath: ChunkPath) {\n  runtimeChunkLists.add(chunkListPath);\n}\n\nfunction registerChunk([\n  chunkPath,\n  chunkModules,\n  runtimeParams,\n]: ChunkRegistration) {\n  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n    if (!moduleFactories[moduleId]) {\n      moduleFactories[moduleId] = moduleFactory;\n    }\n    addModuleToChunk(moduleId, chunkPath);\n  }\n\n  return BACKEND.registerChunk(chunkPath, runtimeParams);\n}\n\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];\n\nconst chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS;\nif (Array.isArray(chunkListsToRegister)) {\n  for (const chunkList of chunkListsToRegister) {\n    registerChunkList(globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS, chunkList);\n  }\n}\n\nglobalThis.TURBOPACK_CHUNK_LISTS = {\n  push: (chunkList) => {\n    registerChunkList(globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!, chunkList);\n  },\n} satisfies ChunkListProvider;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 909, "column": 0}, "map": {"version":3,"sources":["/turbopack/[turbopack]/dev/runtime/nodejs/runtime-backend-nodejs.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack development\n * ECMAScript Node.js runtime.\n *\n * It will be appended to the base development runtime code.\n */\n\n/// <reference path=\"../base/runtime-base.ts\" />\n\ninterface RequireContextEntry {\n  // Only the Node.js backend has this flag.\n  external: boolean;\n}\n\ntype ExternalRequire = (id: ModuleId) => Exports | EsmNamespaceObject;\n\ninterface TurbopackDevContext {\n  x: ExternalRequire;\n}\n\nfunction commonJsRequireContext(\n  entry: RequireContextEntry,\n  sourceModule: Module\n): Exports {\n  return entry.external\n    ? externalRequire(entry.id(), false)\n    : commonJsRequire(sourceModule, entry.id());\n}\n\nfunction externalRequire(\n  id: ModuleId,\n  esm: boolean = false\n): Exports | EsmNamespaceObject {\n  let raw;\n  try {\n    raw = require(id);\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`);\n  }\n  if (!esm) {\n    return raw;\n  }\n  const ns = {};\n  interopEsm(raw, ns, raw.__esModule);\n  return ns;\n}\nexternalRequire.resolve = (\n  id: string,\n  options?:\n    | {\n        paths?: string[] | undefined;\n      }\n    | undefined\n) => {\n  return require.resolve(id, options);\n};\n\nfunction augmentContext(context: TurbopackDevBaseContext): TurbopackDevContext {\n  const nodejsContext = context as TurbopackDevContext;\n  nodejsContext.x = externalRequire;\n  return nodejsContext;\n}\n\nlet BACKEND: RuntimeBackend;\n\n(() => {\n  BACKEND = {\n    registerChunk(chunkPath, params) {\n      if (params == null) {\n        return;\n      }\n\n      if (params.runtimeModuleIds.length > 0) {\n        for (const otherChunkData of params.otherChunks) {\n          loadChunk(getChunkPath(otherChunkData), {\n            type: SourceType.Runtime,\n            chunkPath,\n          });\n        }\n\n        for (const moduleId of params.runtimeModuleIds) {\n          getOrInstantiateRuntimeModule(moduleId, chunkPath);\n        }\n      }\n    },\n\n    async loadChunk(chunkPath, source) {\n      loadChunk(chunkPath, source);\n    },\n\n    restart: () => {\n      throw new Error(\"restart not implemented for the Node.js backend\");\n    },\n  };\n\n  function loadChunk(chunkPath: ChunkPath, source: SourceInfo) {\n    if (!chunkPath.endsWith(\".js\")) {\n      // We only support loading JS chunks in Node.js.\n      // This branch can be hit when trying to load a CSS chunk.\n      return;\n    }\n\n    let fromChunkPath = undefined;\n    switch (source.type) {\n      case SourceType.Runtime:\n        fromChunkPath = source.chunkPath;\n        break;\n      case SourceType.Parent:\n        fromChunkPath = getFirstModuleChunk(source.parentId);\n        break;\n      case SourceType.Update:\n        break;\n    }\n\n    // We'll only mark the chunk as loaded once the script has been executed,\n    // which happens in `registerChunk`. Hence the absence of `resolve()`.\n    const path = require(\"path\");\n    const resolved = require.resolve(\n      \"./\" + path.relative(path.dirname(fromChunkPath), chunkPath)\n    );\n    delete require.cache[resolved];\n    require(resolved);\n  }\n})();\n\nfunction _eval({ code, url, map }: EcmascriptModuleEntry): ModuleFactory {\n  throw new Error(\"HMR evaluation is not implemented on this backend\");\n}\n"],"names":[],"mappings":";;AAoBA,SAAS,uBACP,KAA0B,EAC1B,YAAoB;IAEpB,OAAO,MAAM,QAAQ,GACjB,gBAAgB,MAAM,EAAE,IAAI,SAC5B,gBAAgB,cAAc,MAAM,EAAE;AAC5C;AAEA,SAAS,gBACP,EAAY,EACZ,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM,QAAQ;IAChB,EAAE,OAAO,KAAK;QAKZ,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,IAAI,CAAC;IAChE;IACA,IAAI,CAAC,KAAK;QACR,OAAO;IACT;IACA,MAAM,KAAK,CAAC;IACZ,WAAW,KAAK,IAAI,IAAI,UAAU;IAClC,OAAO;AACT;AACA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAMA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B;AAEA,SAAS,eAAe,OAAgC;IACtD,MAAM,gBAAgB;IACtB,cAAc,CAAC,GAAG;IAClB,OAAO;AACT;AAEA,IAAI;AAEH,CAAA;IACC,UAAU;QACR,eAAc,SAAS,EAAE,MAAM;YAC7B,IAAI,UAAU,MAAM;gBAClB;YACF;YAEA,IAAI,OAAO,gBAAgB,CAAC,MAAM,GAAG,GAAG;gBACtC,KAAK,MAAM,kBAAkB,OAAO,WAAW,CAAE;oBAC/C,UAAU,aAAa,iBAAiB;wBACtC,MAAM,WAAW,OAAO;wBACxB;oBACF;gBACF;gBAEA,KAAK,MAAM,YAAY,OAAO,gBAAgB,CAAE;oBAC9C,8BAA8B,UAAU;gBAC1C;YACF;QACF;QAEA,MAAM,WAAU,SAAS,EAAE,MAAM;YAC/B,UAAU,WAAW;QACvB;QAEA,SAAS;YACP,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,SAAS,UAAU,SAAoB,EAAE,MAAkB;QACzD,IAAI,CAAC,UAAU,QAAQ,CAAC,QAAQ;YAG9B;QACF;QAEA,IAAI,gBAAgB;QACpB,OAAQ,OAAO,IAAI;YACjB,KAAK,WAAW,OAAO;gBACrB,gBAAgB,OAAO,SAAS;gBAChC;YACF,KAAK,WAAW,MAAM;gBACpB,gBAAgB,oBAAoB,OAAO,QAAQ;gBACnD;YACF,KAAK,WAAW,MAAM;gBACpB;QACJ;QAIA,MAAM,OAAO,QAAQ;QACrB,MAAM,WAAW,QAAQ,OAAO,CAC9B,OAAO,KAAK,QAAQ,CAAC,KAAK,OAAO,CAAC,gBAAgB;QAEpD,OAAO,QAAQ,KAAK,CAAC,SAAS;QAC9B,QAAQ;IACV;AACF,CAAA;AAEA,SAAS,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAyB;IACtD,MAAM,IAAI,MAAM;AAClB"}},
    {"offset": {"line": 986, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}